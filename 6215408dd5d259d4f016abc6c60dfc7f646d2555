{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "05f3cbb8_d3a7891b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 19,
      "author": {
        "id": 1002621
      },
      "writtenOn": "2026-01-23T12:25:55Z",
      "side": 1,
      "message": "Add Tested section with unit test results",
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0ee2ed9_32b31dfb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 19,
      "author": {
        "id": 1002607
      },
      "writtenOn": "2026-01-27T05:15:12Z",
      "side": 1,
      "message": "ackowledged",
      "parentUuid": "05f3cbb8_d3a7891b",
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11e64fbb_02984b60",
        "filename": "platform-mc/terminus_manager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 311,
      "author": {
        "id": 1000926
      },
      "writtenOn": "2026-02-03T08:35:40Z",
      "side": 1,
      "message": "1) Is there a guarantee that PLDM support is the same between the different mediums?\n\n2) This would prioritize mediums that are available at stand-by over others. For example for a plug-n-play PCIe card this could prioritize slow I2C medium over fast PCIe VDM.",
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56ceb844_5f03652d",
        "filename": "platform-mc/terminus_manager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 311,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2026-02-14T13:09:31Z",
      "side": 1,
      "message": "\u003e1) Is there a guarantee that PLDM support is the same between the different mediums?\n\nGood question. It is possible that a device can choose to provide different level of PLDM support over different bindings. \n- Such a device will have single TL PDR or multiple? \n- Also, any thoughts on how TID assignment will happen in such cases? \n\n\n\u003e 2) This would prioritize mediums that are available at stand-by over others. For example for a plug-n-play PCIe card this could prioritize slow I2C medium over fast PCIe VDM.\n\nYou are right. This is something which we are also interested to implement.\n \nPLDM should choose available higher‑bandwidth MCTP binding mediums/network to communicate —for example, PCIe would rank above I2C/I3C as you mentioned.\n\nAnother point is that both the mediums might not be available all the time. For instance, an I2C path to a PCIe card may be available earlier, while the PCIe path becomes usable only after PCIe enumeration completes. In such cases, PLDM could begin communication over I2C and then switch to PCIe once it becomes available.\n\n\n@jk@ozlabs.org Is it feasible to expose MCTP binding information under each MCTP device object paths to implement something like above? If not binding information, another option I can think of is the max speed/bandwidth of the network/binding.",
      "parentUuid": "11e64fbb_02984b60",
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9235f17e_3711a4be",
        "filename": "platform-mc/terminus_manager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 311,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2026-02-16T03:41:33Z",
      "side": 1,
      "message": "\u003e @jk@ozlabs.org Is it feasible to expose MCTP binding information under each MCTP device object paths to implement something like above?\n\nYes, but it\u0027s not as simple as you\u0027re proposing:\n\n - an EID-referenced endpoint object may have *no* physical binding associated (eg., where it is bridged)\n - an EID-referenced endpoint object may have *multiple* physical bindings associated (eg., where there are multiple paths to the endpoint, like DSP0236 Figure 9(A) \u0026 Figure 14)\n\nThere seem to be two use-cases above:\n\n 1. Where the endpoint\u0027s MCTP interfaces are the same across two transport types, and the transports should be selected based on some desired performance metric\n \n 2. Where the endpoint\u0027s MCTP interfaces vary across the two transports, so the transport must be selected on some application-level logic\n\nWhich influences the routing \u0026 EID allocation setup:\n \nFor (2), we would require separate EIDs to be assigned across those two transports, so that the application logic has some chance of determining which remote interface to interact with.\n \nIn this case, you would need some sort of policy to select an EID in the application layer, right? Or are you proposing we rely on mctpd\u0027s dbus objects to determine this (ie, using the proposed transport type data, noting that won\u0027t work for bridged cases)\n\nFor (1), I would suggest using the same EID across both transports on the remote; the selection of the \"best\" interface would then be a kernel routing decision, with no application awareness required.\n\nIn this case, nothing needs to consume the transport type data, it\u0027s only used at routing setup time.",
      "parentUuid": "56ceb844_5f03652d",
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d72d3e8c_b5d77149",
        "filename": "platform-mc/terminus_manager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 320,
      "author": {
        "id": 1002621
      },
      "writtenOn": "2026-01-23T12:25:55Z",
      "side": 1,
      "message": "else if (...)",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 320,
        "endChar": 66
      },
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3cba3843_e5053129",
        "filename": "platform-mc/terminus_manager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 320,
      "author": {
        "id": 1002607
      },
      "writtenOn": "2026-01-27T05:15:12Z",
      "side": 1,
      "message": "acknowledged",
      "parentUuid": "d72d3e8c_b5d77149",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 320,
        "endChar": 66
      },
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4143f7d1_81296f62",
        "filename": "platform-mc/terminus_manager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 332,
      "author": {
        "id": 1002621
      },
      "writtenOn": "2026-01-23T12:25:55Z",
      "side": 1,
      "message": "Why are you unmapTid() and Returning success - If UUID is matched but TID is not matched, They there is some issue in mapping which need to refresh.",
      "range": {
        "startLine": 329,
        "startChar": 0,
        "endLine": 332,
        "endChar": 21
      },
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba638450_ec2791f9",
        "filename": "platform-mc/terminus_manager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 332,
      "author": {
        "id": 1002607
      },
      "writtenOn": "2026-01-27T05:15:12Z",
      "side": 1,
      "message": "Agreed. I will add this UUID comparison logic during the discovery phase so that there is no duplicate device in the mapping",
      "parentUuid": "4143f7d1_81296f62",
      "range": {
        "startLine": 329,
        "startChar": 0,
        "endLine": 332,
        "endChar": 21
      },
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "677e488c_b072fd77",
        "filename": "platform-mc/terminus_manager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 354,
      "author": {
        "id": 1002621
      },
      "writtenOn": "2026-01-23T12:25:55Z",
      "side": 1,
      "message": "With your current changes \"isMapped\" is always false - But that seems to be wrong - Correct the logic as per other comment.",
      "range": {
        "startLine": 354,
        "startChar": 4,
        "endLine": 354,
        "endChar": 18
      },
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd5df7c6_c50bea40",
        "filename": "platform-mc/terminus_manager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 354,
      "author": {
        "id": 1002607
      },
      "writtenOn": "2026-01-27T05:15:12Z",
      "side": 1,
      "message": "I will revert the back the 317 line change so this should be solved. But in af-mctp case it will still be the case as you said since we will be forcing preallocated TID always.",
      "parentUuid": "677e488c_b072fd77",
      "range": {
        "startLine": 354,
        "startChar": 4,
        "endLine": 354,
        "endChar": 18
      },
      "revId": "6215408dd5d259d4f016abc6c60dfc7f646d2555",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}