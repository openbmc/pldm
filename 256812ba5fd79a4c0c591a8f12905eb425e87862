{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "258576dc_e6e79038",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 201,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2022-09-29T09:05:08Z",
      "side": 1,
      "message": "May i know what is the reason behind this multiplication.\nAlso, note that the pdr field having type as real32 can support value \"Unknown\", \u0027infinite\u0027 etc.. We should be able to check/support those as well.",
      "range": {
        "startLine": 201,
        "startChar": 40,
        "endLine": 201,
        "endChar": 48
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f18eafa_4fed93eb",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 201,
      "author": {
        "id": 1000957
      },
      "writtenOn": "2022-10-03T14:15:57Z",
      "side": 1,
      "message": "The multiplication is fixed by patchset 35 to 10000000 to convert second to microsecond.\n\nDoes \"unknown\" in the description of DSP0248 means NaN? How do we ensure the value of NaN in between two PLDM terminus are equal since the float NaN and infinity are implementation defined.",
      "parentUuid": "258576dc_e6e79038",
      "range": {
        "startLine": 201,
        "startChar": 40,
        "endLine": 201,
        "endChar": 48
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33c4b993_7ba16dbd",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 201,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2022-11-14T09:04:23Z",
      "side": 1,
      "message": "I wasn\u0027t able to find an exact line in spec which say it, but I believe by value \"Unknown\" they mean NaN.\n\nComing to the implementation side of it, as per DSP0248 update_interval is real32. And DSP0240 defines how to represent NaN for real32. As long as all the devices stick to it, all terminus will have same implementation.",
      "parentUuid": "2f18eafa_4fed93eb",
      "range": {
        "startLine": 201,
        "startChar": 40,
        "endLine": 201,
        "endChar": 48
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "131ededb_54114321",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 201,
      "author": {
        "id": 1000957
      },
      "writtenOn": "2022-12-07T04:55:38Z",
      "side": 1,
      "message": "Fixed.\nIf update_interval is NaN, UpdateTime is assigned to 0.\nThe polling loop skips sensor when its updateTime is 0.",
      "parentUuid": "33c4b993_7ba16dbd",
      "range": {
        "startLine": 201,
        "startChar": 40,
        "endLine": 201,
        "endChar": 48
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2687a9fc_7b07c167",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 201,
      "author": {
        "id": 1000957
      },
      "writtenOn": "2022-12-07T08:48:06Z",
      "side": 1,
      "message": "Fixed again.\nIf update_interval is NaN, UpdateTime is assigned to std::numeric_limits\u003cunit64_t\u003e::max().\nThe polling loop skips sensor when its updateTime is max.",
      "parentUuid": "131ededb_54114321",
      "range": {
        "startLine": 201,
        "startChar": 40,
        "endLine": 201,
        "endChar": 48
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1363b1d_4a38a583",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 232,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2022-09-29T09:05:08Z",
      "side": 1,
      "message": "Note:- Resolution can have NaN value.",
      "range": {
        "startLine": 232,
        "startChar": 22,
        "endLine": 232,
        "endChar": 32
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "12781a88_bbec4eb9",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 232,
      "author": {
        "id": 1000957
      },
      "writtenOn": "2022-10-03T14:15:57Z",
      "side": 1,
      "message": "Added std::isnan() checking. If resolution is NaN then use 1.0 instead.\n\nBut I have question here since the value of resolution is from PDR and the NaN of float and double are implementation-defined. How does PLDM terminus side know what value is interpreted by BMC as NaN?",
      "parentUuid": "c1363b1d_4a38a583",
      "range": {
        "startLine": 232,
        "startChar": 22,
        "endLine": 232,
        "endChar": 32
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2da1a34_d475f53c",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 232,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2022-11-14T09:04:23Z",
      "side": 1,
      "message": "Not exactly. Resolution is of type real32. So NaN will be represented in the same format as defined for real32(DSP0240).",
      "parentUuid": "12781a88_bbec4eb9",
      "range": {
        "startLine": 232,
        "startChar": 22,
        "endLine": 232,
        "endChar": 32
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "55e37c88_f48da8dd",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 232,
      "author": {
        "id": 1000957
      },
      "writtenOn": "2022-12-07T04:55:38Z",
      "side": 1,
      "message": "Fixed by adding NaN check.",
      "parentUuid": "d2da1a34_d475f53c",
      "range": {
        "startLine": 232,
        "startChar": 22,
        "endLine": 232,
        "endChar": 32
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5844301_3b0242ec",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 328,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2022-09-29T09:05:08Z",
      "side": 1,
      "message": "do we need similar NaN check for thresholdWarningIntf at L291 as well?",
      "range": {
        "startLine": 327,
        "startChar": 33,
        "endLine": 328,
        "endChar": 77
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49c85333_8fac1876",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 328,
      "author": {
        "id": 1000957
      },
      "writtenOn": "2022-10-03T14:15:57Z",
      "side": 1,
      "message": "I didn\u0027t add NaN check for thresholdWarningIntf because of description of rangeFieldSupport in Table 102 of DSP0248 v1.2.1. It says that warningHigh and warningLow fields are always supported.\n\nI think the definitions of supportedThresholds and rangeFieldSupport are not aligned. The supportedThsholds field says that warning thresholds can be optional but rangeFieldSupport doesn\u0027t.",
      "parentUuid": "c5844301_3b0242ec",
      "range": {
        "startLine": 327,
        "startChar": 33,
        "endLine": 328,
        "endChar": 77
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f14877d2_5c35f0d0",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 328,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2022-11-14T09:04:23Z",
      "side": 1,
      "message": "I suppose you are refering to table 78. Table 102 is compact sensor.\nAnd you are right, the spec itself callout(table 78, rangeFieldSupport definition) that it is an error in original specification and will be corrected in next major release.\n\nI dont have a strong opinion but to be on the safer side since the data type can support NaN, may be we can add the NaN check.",
      "parentUuid": "49c85333_8fac1876",
      "range": {
        "startLine": 327,
        "startChar": 33,
        "endLine": 328,
        "endChar": 77
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b9b4bf08_c4901575",
        "filename": "platform-mc/numeric_sensor.cpp",
        "patchSetId": 33
      },
      "lineNbr": 328,
      "author": {
        "id": 1000957
      },
      "writtenOn": "2022-12-07T04:55:38Z",
      "side": 1,
      "message": "Fixed by adding NaN check.",
      "parentUuid": "f14877d2_5c35f0d0",
      "range": {
        "startLine": 327,
        "startChar": 33,
        "endLine": 328,
        "endChar": 77
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf8a0e8a_169d31f5",
        "filename": "platform-mc/sensor_manager.cpp",
        "patchSetId": 33
      },
      "lineNbr": 71,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2022-09-29T09:05:08Z",
      "side": 1,
      "message": "nit: please avoid magic numbers for easy understanding.",
      "range": {
        "startLine": 71,
        "startChar": 57,
        "endLine": 71,
        "endChar": 60
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9b8beef8_f73ecdea",
        "filename": "platform-mc/sensor_manager.cpp",
        "patchSetId": 33
      },
      "lineNbr": 71,
      "author": {
        "id": 1000957
      },
      "writtenOn": "2022-10-03T14:15:57Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "cf8a0e8a_169d31f5",
      "range": {
        "startLine": 71,
        "startChar": 57,
        "endLine": 71,
        "endChar": 60
      },
      "revId": "256812ba5fd79a4c0c591a8f12905eb425e87862",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}