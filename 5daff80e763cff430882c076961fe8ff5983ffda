{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f09a66cf_0731fd7f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 10,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "what do you mean by far terminus ? is this a specification term ?",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00ce9ff1_f33e3e61",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 10,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "can you mention the sequence of operations that happens before this, and which step this fix is going in.. that will give a better picture of what you are trying to achieve.",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64e0276c_26d85aad",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 10,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "I was under the assumption that we dont have any blocking methods as such ..may be I am mistaken. can you point out here on what is exactly being a blocking method ..and what this method is blocking ?",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "957e1d9d_690b18a9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 10,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-05T04:32:19Z",
      "side": 1,
      "message": "Commit msg updated.",
      "parentUuid": "00ce9ff1_f33e3e61",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "92332344_fc86e976",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 10,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-05T04:32:19Z",
      "side": 1,
      "message": "Commit msg updated.",
      "parentUuid": "64e0276c_26d85aad",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f33586d0_963136bd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 10,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-05T04:32:19Z",
      "side": 1,
      "message": "Updated.",
      "parentUuid": "f09a66cf_0731fd7f",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9bc5cbd9_5779e5ab",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 13,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "I was thinking that with the help of coroutine based infrastructure, it does not matter how long it takes to construct..but the application will always be responsive enough during that time ? is my understanding wrong ?",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69dd21fe_a1b7e917",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 13,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-05T04:32:19Z",
      "side": 1,
      "message": "Commit msg updated.",
      "parentUuid": "9bc5cbd9_5779e5ab",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0572c365_97578368",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 16,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "why cant we achive the same by pushing th task onto an eventloop ? why did we prefer going with the timer approach.",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef9c2b19_2a02f96e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 16,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-02-26T03:27:34Z",
      "side": 1,
      "message": "Are you mentioning defer task? As I defined a default 0 interval timer, I assume they-re not too different while a timer is easier to implement. Not to mention it allows a reconfiguration to the interval, like we prefer a 5 ms interval. Above all, it\u0027s just that I\u0027m more familiar with time. If defer has more advantages, I will consider.",
      "parentUuid": "0572c365_97578368",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ef3bb7a_78c64824",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 16,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-03-03T04:09:45Z",
      "side": 1,
      "message": "\u003e Are you mentioning defer task? As I defined a default 0 interval timer, I assume they-re not too different while a timer is easier to implement. Not to mention it allows a reconfiguration to the interval, like we prefer a 5 ms interval. Above all, it\u0027s just that I\u0027m more familiar with time. If defer has more advantages, I will consider.\n\n\nI get your point, but if we can achieve the same result without any new infrastructure, that would be ideal, right ? Having a meson option for configuring a timer to create the dbus objects is not the kind of flexibility we should give to users - rather we should try and optimize the code so that portions of the code can be split so that it can be scheduled better And also take `retries` mentioned in the pldm spec to a good advantage to negate the effects of slow processor/bus speeds.\n\nexample of defering a certain function on to eventloop - so that process remains response:\nhttps://github.com/openbmc/pldm/blob/master/host-bmc/host_pdr_handler.cpp#L159",
      "parentUuid": "ef9c2b19_2a02f96e",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e797b09_653b9219",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 16,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-03T05:15:31Z",
      "side": 1,
      "message": "That makes sense. I will try `defer` out for `addNextSensorFromPDRs` in my current patch, instead of a timer, and give feedback.",
      "parentUuid": "8ef3bb7a_78c64824",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3271038_8982d1b0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 16,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-03T10:35:52Z",
      "side": 1,
      "message": "UPDATE: I tried using defer for `addNextSensorFromPDRs()` as the below implementation, which modifies to my current patch set. Defer event source is set to Enabled::OneShot right after the callback is executed in order to add it to the queue again, cuz Defer is One-Shot by default. However, events from Host are still processed ONLY AFTER all the sensor objects are created. I don\u0027t know why host events couldn\u0027t intervene in, will investigate more to find out why.\n\n       terminus.hpp: private member: std::unique_ptr\u003csdeventplus::source::Defer\u003e sensorCreationEvent;\n       \n       ...\n       terminus.cpp:\n    \n       void Terminus::parseTerminusPDRs()\n       {\n          /*...parse PDRs to pdr structs */\n   \n          sensorCreationEvent \u003d std::make_unique\u003csdeventplus::source::Defer\u003e(\n             event, std::bind(std::mem_fn(\u0026Terminus::addNextSensorFromPDRs), this));\n       }\n\n      void Terminus::addNextSensorFromPDRs()\n      {\n          auto pdrIt \u003d sensorPdrIt;\n          if (pdrIt \u003c numericSensorPdrs.size())\n         {\n             const auto pdr \u003d numericSensorPdrs[pdrIt];\n             addNumericSensor(pdr);\n         }\n         else if (pdrIt \u003c numericSensorPdrs.size() + compactNumericSensorPdrs.size())\n         {\n             pdrIt -\u003d numericSensorPdrs.size();\n             const auto pdr \u003d compactNumericSensorPdrs[pdrIt];\n             addCompactNumericSensor(pdr);\n         }\n         else if (pdrIt \u003c numericSensorPdrs.size() + compactNumericSensorPdrs.size()\n             + numericEffecterPdrs.size())\n         {\n             pdrIt -\u003d numericSensorPdrs.size() + compactNumericSensorPdrs.size();\n             const auto pdr \u003d numericEffecterPdrs[pdrIt];\n             addNumericEffecter(pdr);\n         }\n         else\n         {\n             sensorCreationEvent.reset();\n             return;\n         }\n\n         sensorPdrIt++;\n         sensorCreationEvent-\u003eset_enabled(sdeventplus::source::Enabled::OneShot);\n      }",
      "parentUuid": "1e797b09_653b9219",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15aac04f_530262b6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 16,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-05T04:32:19Z",
      "side": 1,
      "message": "I changed to delete and create new defer event source each time addNumericSensor is called (latest PS), then events from Host could break in. It seems like with my old implementation, all defer events are dispatched in the same event loop before preparing again. I can\u0027t tell exactly what differentiate 2 implementations. Hope to hear your thoughts. Also, some tests are modified to adapt with new defer tasks, because sensors won\u0027t be added right after the PDRs are parsed.",
      "parentUuid": "c3271038_8982d1b0",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4dea2003_7c72c3aa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "Hey Thu - I have a lot of questions on this one. The commit message really does not explain the core problem in detail. Can you please take a stab it the commit message again and explain it in layman terms ? \n\nI would like to see something like:\n\ncurrent behaviour:\n1. `a` happens\n2. then `b` happens\n3. then `c` starts\n4. but then `c` is blocking, so it does not allow us from doing `d`\n\nand also mention the reasons why `c` is made a blocking call ..and what are the other options explored to make `c` a non-blocking call. Why did we choose to opt for the timer approach what are the merits in that ? with respect to its alternative solutions.\n\nNow with the fix , what the behaviour:\n1. \u003c\u003e\n2. \u003c\u003e\n....\n\nThis would give me and any others a better chance at understanding the problem being solved.",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "393cfcff_8379abdf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-02-26T03:27:34Z",
      "side": 1,
      "message": "Hi @ManojKiran Eda, sorry for the unclarity in the commit msg. Can you please first look at the reasons below and share your thoughts before I modify the commit msg and officially address your other comments. CC anh @thu@os.amperecomputing.com\n\nAfter all PDRs retrieved from the other terminus are parsed into pdr structs. They will be processed to create sensor objects (e.g via addNumericSensor function for Numeric Sensors).\n\nDuring this phase for one sensor, sensor name is achieved (may enlist Sensor Aux Name PDRs), and NumericSensor object is constructed. Sensor object construction involves parsing pdr struct elements into sensor class variables, D-Bus interface initialization and many calls to set D-Bus object properties.\n\nExcept for the D-Bus calls (which are setting properties to the D-Bus objects that pldmd itself holds so I think it\u0027s not waiting for responses, and I don\u0027t know if we can improve something here, please share your thoughts), all the other actions are not making any io call. Therefore, coroutine is not helpful here.\n\nThey actually may not be blocking actions, but as it continuously loops through sensor PDRs in `parseTerminusPDRs` to add sensors, they take too much time and prevent BMC from processing events coming from other termini. Not to mention the adding of new sensor types in the future and the increase in sensor numbers, the total time will be large.\n\nFor Ampere Mt.Jefferson platform, it takes around 1.5s to construct 156 Numeric and Compact Numeric sensors. As we also receive Boot Progress events from Host during the init phase, it exceeds Request-To-Response timeout of 100ms in Table 5 DSP0240 if Boot Progress event comes while BMC is creating sensor objects.\n\nAs it\u0027s not essential to create sensor objects that fast, I chose to use a timer to delay the creation of each sensor in the PDR list. Instead of a continuous loop through sensor PDRs to do thetask.",
      "parentUuid": "4dea2003_7c72c3aa",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ccfdaa8b_3c4720ec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-03-03T04:09:45Z",
      "side": 1,
      "message": "\u003e Except for the D-Bus calls (which are setting properties to the D-Bus objects that pldmd itself holds so I think it\u0027s not waiting for responses, and I don\u0027t know if we can improve something here, please share your thoughts), all the other actions are not making any io call. Therefore, coroutine is not helpful here.\n\u003e \n\nThanks for the explanation. This gave me an excellent understanding on where the problem is.\n\nSo the crux is that when we create the dbus objects and we set the properties, the delay is coming from that place? am I understanding it right?\n\nCan we do an exercise on which function is taking more time in the entire process?  is it at the processing of the PDR\u0027s ? or is it at the parsing place? or creating the dbus objects? can you measure the time taken for each of these functions ? and tell which function exactly is taking time ? \n\n\ncreating the dbus objects should not be slow, as you are not backing the dbus objects with the filesystem (serial persistence).\n\nif the creation of dbus objects takes time, we can defer that out to the event loop , so that the scheduler will create them when pldmd was not busy with something else.\n\nan example for deferring a task to event loop : https://github.com/openbmc/pldm/blob/36b36938a4eedcf87d3918acc10b07a28e7f1e9d/host-bmc/host_pdr_handler.cpp#L159\n\n\n\n\n\u003e They actually may not be blocking actions, but as it continuously loops through sensor PDRs in `parseTerminusPDRs` to add sensors, they take too much time and prevent BMC from processing events coming from other termini. Not to mention the adding of new sensor types in the future and the increase in sensor numbers, the total time will be large.\n\u003e \n\u003e For Ampere Mt.Jefferson platform, it takes around 1.5s to construct 156 Numeric and Compact Numeric sensors. As we also receive Boot Progress events from Host during the init phase, it exceeds Request-To-Response timeout of 100ms in Table 5 DSP0240 if Boot Progress event comes while BMC is creating sensor objects.\n\u003e \n\nWell, are there no retries in place for your pldm stack? less than a 2-second with just one request is a little too restrictive. If retries are in place then you would not have this problem at all right ?\n\n\u003e As it\u0027s not essential to create sensor objects that fast, I chose to use a timer to delay the creation of each sensor in the PDR list. Instead of a continuous loop through sensor PDRs to do thetask.",
      "parentUuid": "393cfcff_8379abdf",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8db98dad_7bfcd736",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-03T05:15:31Z",
      "side": 1,
      "message": "Thank you @manojkiran.eda@gmail.com for your response. I will soon give a brief timing measure from our system.\n\n\u003e Well, are there no retries in place for your pldm stack? less than a 2-second with just one request is a little too restrictive. If retries are in place then you would not have this problem at all right ?\n\nWe do have `retries` scheme on Host side: 2 retries, 500ms each if response is not received from BMC. After totally 1.5s, Host will consider it as a timeout.\n\nTherefore, if the request is sent during the sensor creation task of BMC, when BMC finishes creating sensors (1.5s), BMC will process 3 requests of the same message content in the queue and respond to them, but it\u0027s late. BMC can still receive the event (actually 3 of them), but does not have method to filter out duplication, and Host screams out a timeout. Those are not desirable.",
      "parentUuid": "ccfdaa8b_3c4720ec",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ac26d67_4d8577b1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-03T10:35:52Z",
      "side": 1,
      "message": "Hi, to give an example tested on our system:\n\n* `parse...PDR` functions are not mentioned as they use coroutine\n\n* In `addNumericSensor`/`addCompactNumericSensor`, as they both use NumericSensor class so I take them as 1:\n\n - getSensorAuxiliaryNames: around **0.2ms -\u003e 1ms** (depending on where the name lies in the vector)\n\n - NumericSensor object construction: **1xms -\u003e 2xms**\n\n* In NumericSensor constructor:\n\n - getService (to throw if the object path already exists on D-Bus): around **10ms**\n\n - parsing threshold properties from PDR bitfields: around **0.3ms**\n - Association/Entity/Sensor.Value/Availability/Operational.Status/Threshold.Warning/Threshold.Critical interfaces (totally 7 interfaces): around **1ms each** to create interface and set necessary property values. Some sensor does not have threshold configurations, so it varies among sensors about the time needed to construct all D-Bus interfaces.\n\n\nTherefore, the most expensive part is NumericSensor object construction: **1x ms - 2x ms** (depending on sensor PDR characteristics and D-Bus traffic at the time).",
      "parentUuid": "8db98dad_7bfcd736",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}