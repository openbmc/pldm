{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f09a66cf_0731fd7f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 10,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "what do you mean by far terminus ? is this a specification term ?",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00ce9ff1_f33e3e61",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 10,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "can you mention the sequence of operations that happens before this, and which step this fix is going in.. that will give a better picture of what you are trying to achieve.",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64e0276c_26d85aad",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 10,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "I was under the assumption that we dont have any blocking methods as such ..may be I am mistaken. can you point out here on what is exactly being a blocking method ..and what this method is blocking ?",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9bc5cbd9_5779e5ab",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 13,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "I was thinking that with the help of coroutine based infrastructure, it does not matter how long it takes to construct..but the application will always be responsive enough during that time ? is my understanding wrong ?",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0572c365_97578368",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 16,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "why cant we achive the same by pushing th task onto an eventloop ? why did we prefer going with the timer approach.",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef9c2b19_2a02f96e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 16,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-02-26T03:27:34Z",
      "side": 1,
      "message": "Are you mentioning defer task? As I defined a default 0 interval timer, I assume they-re not too different while a timer is easier to implement. Not to mention it allows a reconfiguration to the interval, like we prefer a 5 ms interval. Above all, it\u0027s just that I\u0027m more familiar with time. If defer has more advantages, I will consider.",
      "parentUuid": "0572c365_97578368",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ef3bb7a_78c64824",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 16,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-03-03T04:09:45Z",
      "side": 1,
      "message": "\u003e Are you mentioning defer task? As I defined a default 0 interval timer, I assume they-re not too different while a timer is easier to implement. Not to mention it allows a reconfiguration to the interval, like we prefer a 5 ms interval. Above all, it\u0027s just that I\u0027m more familiar with time. If defer has more advantages, I will consider.\n\n\nI get your point, but if we can achieve the same result without any new infrastructure, that would be ideal, right ? Having a meson option for configuring a timer to create the dbus objects is not the kind of flexibility we should give to users - rather we should try and optimize the code so that portions of the code can be split so that it can be scheduled better And also take `retries` mentioned in the pldm spec to a good advantage to negate the effects of slow processor/bus speeds.\n\nexample of defering a certain function on to eventloop - so that process remains response:\nhttps://github.com/openbmc/pldm/blob/master/host-bmc/host_pdr_handler.cpp#L159",
      "parentUuid": "ef9c2b19_2a02f96e",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4dea2003_7c72c3aa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-02-25T11:20:25Z",
      "side": 1,
      "message": "Hey Thu - I have a lot of questions on this one. The commit message really does not explain the core problem in detail. Can you please take a stab it the commit message again and explain it in layman terms ? \n\nI would like to see something like:\n\ncurrent behaviour:\n1. `a` happens\n2. then `b` happens\n3. then `c` starts\n4. but then `c` is blocking, so it does not allow us from doing `d`\n\nand also mention the reasons why `c` is made a blocking call ..and what are the other options explored to make `c` a non-blocking call. Why did we choose to opt for the timer approach what are the merits in that ? with respect to its alternative solutions.\n\nNow with the fix , what the behaviour:\n1. \u003c\u003e\n2. \u003c\u003e\n....\n\nThis would give me and any others a better chance at understanding the problem being solved.",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "393cfcff_8379abdf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-02-26T03:27:34Z",
      "side": 1,
      "message": "Hi @ManojKiran Eda, sorry for the unclarity in the commit msg. Can you please first look at the reasons below and share your thoughts before I modify the commit msg and officially address your other comments. CC anh @thu@os.amperecomputing.com\n\nAfter all PDRs retrieved from the other terminus are parsed into pdr structs. They will be processed to create sensor objects (e.g via addNumericSensor function for Numeric Sensors).\n\nDuring this phase for one sensor, sensor name is achieved (may enlist Sensor Aux Name PDRs), and NumericSensor object is constructed. Sensor object construction involves parsing pdr struct elements into sensor class variables, D-Bus interface initialization and many calls to set D-Bus object properties.\n\nExcept for the D-Bus calls (which are setting properties to the D-Bus objects that pldmd itself holds so I think it\u0027s not waiting for responses, and I don\u0027t know if we can improve something here, please share your thoughts), all the other actions are not making any io call. Therefore, coroutine is not helpful here.\n\nThey actually may not be blocking actions, but as it continuously loops through sensor PDRs in `parseTerminusPDRs` to add sensors, they take too much time and prevent BMC from processing events coming from other termini. Not to mention the adding of new sensor types in the future and the increase in sensor numbers, the total time will be large.\n\nFor Ampere Mt.Jefferson platform, it takes around 1.5s to construct 156 Numeric and Compact Numeric sensors. As we also receive Boot Progress events from Host during the init phase, it exceeds Request-To-Response timeout of 100ms in Table 5 DSP0240 if Boot Progress event comes while BMC is creating sensor objects.\n\nAs it\u0027s not essential to create sensor objects that fast, I chose to use a timer to delay the creation of each sensor in the PDR list. Instead of a continuous loop through sensor PDRs to do thetask.",
      "parentUuid": "4dea2003_7c72c3aa",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ccfdaa8b_3c4720ec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-03-03T04:09:45Z",
      "side": 1,
      "message": "\u003e Except for the D-Bus calls (which are setting properties to the D-Bus objects that pldmd itself holds so I think it\u0027s not waiting for responses, and I don\u0027t know if we can improve something here, please share your thoughts), all the other actions are not making any io call. Therefore, coroutine is not helpful here.\n\u003e \n\nThanks for the explanation. This gave me an excellent understanding on where the problem is.\n\nSo the crux is that when we create the dbus objects and we set the properties, the delay is coming from that place? am I understanding it right?\n\nCan we do an exercise on which function is taking more time in the entire process?  is it at the processing of the PDR\u0027s ? or is it at the parsing place? or creating the dbus objects? can you measure the time taken for each of these functions ? and tell which function exactly is taking time ? \n\n\ncreating the dbus objects should not be slow, as you are not backing the dbus objects with the filesystem (serial persistence).\n\nif the creation of dbus objects takes time, we can defer that out to the event loop , so that the scheduler will create them when pldmd was not busy with something else.\n\nan example for deferring a task to event loop : https://github.com/openbmc/pldm/blob/36b36938a4eedcf87d3918acc10b07a28e7f1e9d/host-bmc/host_pdr_handler.cpp#L159\n\n\n\n\n\u003e They actually may not be blocking actions, but as it continuously loops through sensor PDRs in `parseTerminusPDRs` to add sensors, they take too much time and prevent BMC from processing events coming from other termini. Not to mention the adding of new sensor types in the future and the increase in sensor numbers, the total time will be large.\n\u003e \n\u003e For Ampere Mt.Jefferson platform, it takes around 1.5s to construct 156 Numeric and Compact Numeric sensors. As we also receive Boot Progress events from Host during the init phase, it exceeds Request-To-Response timeout of 100ms in Table 5 DSP0240 if Boot Progress event comes while BMC is creating sensor objects.\n\u003e \n\nWell, are there no retries in place for your pldm stack? less than a 2-second with just one request is a little too restrictive. If retries are in place then you would not have this problem at all right ?\n\n\u003e As it\u0027s not essential to create sensor objects that fast, I chose to use a timer to delay the creation of each sensor in the PDR list. Instead of a continuous loop through sensor PDRs to do thetask.",
      "parentUuid": "393cfcff_8379abdf",
      "revId": "5daff80e763cff430882c076961fe8ff5983ffda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}