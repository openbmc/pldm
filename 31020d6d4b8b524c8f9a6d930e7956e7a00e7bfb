{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "4bc4af3f_1ed7dd4a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2023-09-19T09:05:27Z",
      "side": 1,
      "message": "@Thu - have couple of questions on the testing : \n\n\n1) I have seen cases in the past where , we could not write code like this :\n\n```\nfor(sensor : sensorslist)\n{\n  pldm_send(get_state_sensorreading_command, sensor.sensorId);\n}\n\n```\n\nbecause if the sensors list is more than 32, then we would run out of free instance ids.\n\nNow with your code , does this pattern work ? without we running into the instance id problem ? at a glace on the code - it does not look like it ? \n\n2) There is code in the pldm repo, that would key off of the dbus properties to drive sensor events, for example : a physical led state change would result in a sensor event being generated (if we model led as a PLDM sensor). With this code in place, do we think that the sensor event could be delayed based on the running transactions ?",
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd25ce14_01798a8c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2023-10-18T03:18:07Z",
      "side": 1,
      "message": "About 1 points.\n\nWe can\u0027t write the code like that.\nThe above code should be\n```\nfor(sensor : sensorslist)\n{\n  if (eid\u003dgetInstanceID())\n  {\n      pldm_send(get_state_sensorreading_command, sensor.sensorId);\n  }\n}\n```\nWith the current PLDM code, after sending 32 PLDM the registered request messages to one points without the response from endpoints the next `pldm_send` will be failed because there is no free InstanceID.\n\nAfter my patch set, after there are 32 registered request messages to endpoints, the registered messages will be queued and send one by one. The 33th message will be failed when there are no response message for the sent message to one endpoint because no free InstanceID.\n\nSo the pattern still is failed.\n\nAbout point 2th,\nWhich is the source of the event? If the source of the event is BMC, I think it should be one effecter setting from BMC right?\n\nIf the source is from BMC then the answer is yes. But I don\u0027t think the delay is too long. One PLDM transaction takes only 1-2ms to be done. The response time of host can be different but I don\u0027t think it more than 10ms for sensor reading.",
      "parentUuid": "4bc4af3f_1ed7dd4a",
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dcda2b10_fea6750a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2023-10-18T03:22:44Z",
      "side": 1,
      "message": "@ManojKiran Eda, does your MCU support multi threads in handling the pldm request? And support multi threads collecting the data to response for the pldm request?",
      "parentUuid": "dd25ce14_01798a8c",
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6779bae_88375705",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 69,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2023-09-19T09:05:27Z",
      "side": 1,
      "message": "could we add little more documentation about this struct like above ?",
      "range": {
        "startLine": 69,
        "startChar": 0,
        "endLine": 69,
        "endChar": 24
      },
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e15b7e4a_f5f6f94d",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 69,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2023-10-18T02:41:27Z",
      "side": 1,
      "message": "Added.",
      "parentUuid": "e6779bae_88375705",
      "range": {
        "startLine": 69,
        "startChar": 0,
        "endLine": 69,
        "endChar": 24
      },
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71add0c3_553e37b7",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2023-09-19T09:05:27Z",
      "side": 1,
      "message": "little more documentation on what this struct is about is needed.",
      "range": {
        "startLine": 76,
        "startChar": 0,
        "endLine": 76,
        "endChar": 27
      },
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52740da1_3df76b92",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2023-10-18T02:41:27Z",
      "side": 1,
      "message": "Added.",
      "parentUuid": "71add0c3_553e37b7",
      "range": {
        "startLine": 76,
        "startChar": 0,
        "endLine": 76,
        "endChar": 27
      },
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba4b2f63_2b6cc8a9",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 80,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-09-19T01:37:27Z",
      "side": 1,
      "message": "maybe `activeRequest`?",
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "383bf298_53b7824d",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 80,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2023-10-18T02:41:27Z",
      "side": 1,
      "message": "Updated.",
      "parentUuid": "ba4b2f63_2b6cc8a9",
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "341da624_0e8dc2d0",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 182,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-09-19T01:37:27Z",
      "side": 1,
      "message": "The request isn\u0027t started if one is already active though? What properties is this method trying to uphold with respect to the queue?\n\nPerhaps this method is better named `pollEndpointQueue()`?",
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "92803aae_9e23bc48",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 182,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2023-10-18T02:41:27Z",
      "side": 1,
      "message": "Updated.",
      "parentUuid": "341da624_0e8dc2d0",
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4da23ea_e89cb10f",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 187,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-09-19T01:37:27Z",
      "side": 1,
      "message": "Instead of the `waitForRespMsg` boolean maybe we could use `std::optional\u003cstd::shared_ptr\u003cRegisteredRequest\u003e\u003e`? If it\u0027s empty there\u0027s no active request, and if it\u0027s populated then there is an active request.",
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "14b93607_ec600e75",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2023-09-19T09:05:27Z",
      "side": 1,
      "message": "use map.contains() instead and make it more readable ?",
      "range": {
        "startLine": 253,
        "startChar": 12,
        "endLine": 253,
        "endChar": 75
      },
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8f9fa40b_bc6de03d",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2023-10-18T02:41:27Z",
      "side": 1,
      "message": "Updated.",
      "parentUuid": "14b93607_ec600e75",
      "range": {
        "startLine": 253,
        "startChar": 12,
        "endLine": 253,
        "endChar": 75
      },
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b27cef2_f2fba532",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 335,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-09-19T01:37:27Z",
      "side": 1,
      "message": "Would we have fewer headaches if this were an array of std::deque instead? What\u0027s the cost of that vs having to dynamically manage the map? Feels like there are more runtime penalties and more scope for UAF of the deque instance.",
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b6f0962_30f7ec7e",
        "filename": "requester/handler.hpp",
        "patchSetId": 6
      },
      "lineNbr": 335,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2023-10-18T02:41:27Z",
      "side": 1,
      "message": "Because each endpoint with eid needs one messageQueues and also activeRequest state so I don\u0027t think using `an array of std::deque` is possible.",
      "parentUuid": "6b27cef2_f2fba532",
      "revId": "31020d6d4b8b524c8f9a6d930e7956e7a00e7bfb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}