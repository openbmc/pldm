From 5eb3051c7619ceba0cf0b5e7c96983cbe79d0cfa Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang.wiwynn@gmail.com>
Date: Tue, 1 Jul 2025 08:19:56 +0000
Subject: [PATCH] pldm: use std::expected for instance ID allocation

Refactor InstanceIdDb::next() to return
std::expected<uint8_t, InstanceIdError> instead of throwing exceptions.
This change enables callers to explicitly handle allocation errors via
value inspection, rather than relying on exception handling.

This approach prevents core dumps from uncaught exceptions and
eliminates the need for pervasive try-catch blocks.
Callers can now access the error code and message directly, improving
clarity and control of error propagation.

Note:
Errors from InstanceIdDb::next() are currently handled via early
return, which may silently discard failures.
This is a temporary solution; APIs and callers will need to be updated
in the future to propagate and handle errors explicitly.

Change-Id: Ibf2e0034b0ee725cb59adfd93b74e48db8c42cba
Signed-off-by: Eric Yang <eric.yang.wiwynn@gmail.com>
---
 common/instance_id.hpp                        | 75 ++++++++++++++++---
 common/utils.hpp                              | 23 ++++++
 fw-update/device_updater.cpp                  | 57 ++++++++++++--
 fw-update/inventory_manager.cpp               | 55 ++++++++++++--
 host-bmc/dbus_to_event_handler.cpp            |  8 +-
 host-bmc/host_pdr_handler.cpp                 | 48 ++++++++++--
 libpldmresponder/platform.cpp                 |  8 +-
 oem/ibm/host-bmc/host_lamp_test.cpp           |  8 +-
 oem/ibm/libpldmresponder/oem_ibm_handler.cpp  |  8 +-
 oem/ibm/libpldmresponder/platform_oem_ibm.cpp |  8 +-
 oem/ibm/requester/dbus_to_file_handler.cpp    | 16 +++-
 platform-mc/dbus_to_terminus_effecters.cpp    | 16 +++-
 platform-mc/terminus_manager.cpp              | 24 +++++-
 pldmtool/pldm_cmd_helper.cpp                  |  8 +-
 requester/test/handler_test.cpp               | 35 +++++++--
 softoff/softoff.cpp                           |  9 ++-
 16 files changed, 359 insertions(+), 47 deletions(-)

diff --git a/common/instance_id.hpp b/common/instance_id.hpp
index 40de1f1..7390d37 100644
--- a/common/instance_id.hpp
+++ b/common/instance_id.hpp
@@ -5,12 +5,70 @@
 #include <cerrno>
 #include <cstdint>
 #include <exception>
+#include <expected>
 #include <string>
 #include <system_error>
 
 namespace pldm
 {
 
+/**
+ * @class InstanceIdError
+ * @brief Exception for PLDM instance ID allocation and management errors.
+ */
+class InstanceIdError : public std::exception
+{
+  public:
+    InstanceIdError(const InstanceIdError&) noexcept = default;
+    InstanceIdError(InstanceIdError&&) noexcept = default;
+    InstanceIdError& operator=(const InstanceIdError&) noexcept = default;
+    InstanceIdError& operator=(InstanceIdError&&) noexcept = default;
+    ~InstanceIdError() noexcept override = default;
+
+    /** @brief Construct with an error code. */
+    explicit InstanceIdError(int rc) : rc_(rc), msg_(rcToMsg(rc)) {}
+
+    /** @brief Construct with an error code and a string message (copied). */
+    InstanceIdError(int rc, const std::string& m) : rc_(rc), msg_(m) {}
+
+    /** @brief Construct with an error code and a string message (moved). */
+    InstanceIdError(int rc, std::string&& m) : rc_(rc), msg_(std::move(m)) {}
+
+    /** @brief Get the error code. */
+    int rc() const noexcept
+    {
+        return rc_;
+    }
+
+    /** @brief Get the error message. */
+    const std::string& msg() const noexcept
+    {
+        return msg_;
+    }
+
+    /** @brief Convert an error code to a message. */
+    static std::string rcToMsg(int rc)
+    {
+        switch (rc)
+        {
+            case -EAGAIN:
+                return "No free instance ids";
+            default:
+                return std::system_category().message(rc);
+        }
+    }
+
+    /** @brief Get the error message (for std::exception). */
+    const char* what() const noexcept override
+    {
+        return msg_.c_str();
+    }
+
+  private:
+    int rc_;
+    std::string msg_;
+};
+
 /** @class InstanceId
  *  @brief Implementation of PLDM instance id as per DSP0240 v1.0.0
  */
@@ -53,22 +111,21 @@ class InstanceIdDb
 
     /** @brief Allocate an instance ID for the given terminus
      *  @param[in] tid - the terminus ID the instance ID is associated with
-     *  @return - PLDM instance id or -EAGAIN if there are no available instance
-     *            IDs
+     *  @return - PLDM instance id on success, or InstanceIdError if allocation
+     * fails
      */
-    uint8_t next(uint8_t tid)
+    std::expected<uint8_t, InstanceIdError> next(uint8_t tid)
     {
         uint8_t id;
         int rc = pldm_instance_id_alloc(pldmInstanceIdDb, tid, &id);
 
-        if (rc == -EAGAIN)
-        {
-            throw std::runtime_error("No free instance ids");
-        }
-
         if (rc)
         {
-            throw std::system_category().default_error_condition(rc);
+            return std::unexpected(InstanceIdError{
+                rc,
+                "Failed to allocate instance ID for EID " +
+                std::to_string(tid) + ": " + InstanceIdError::rcToMsg(rc)
+            });
         }
 
         return id;
diff --git a/common/utils.hpp b/common/utils.hpp
index 358d0d7..4abd7de 100644
--- a/common/utils.hpp
+++ b/common/utils.hpp
@@ -1,5 +1,6 @@
 #pragma once
 
+#include "instance_id.hpp"
 #include "types.hpp"
 
 #include <libpldm/base.h>
@@ -20,6 +21,7 @@
 #include <cstdint>
 #include <deque>
 #include <exception>
+#include <expected>
 #include <filesystem>
 #include <iostream>
 #include <map>
@@ -164,6 +166,27 @@ T decimalToBcd(T decimal)
     return bcd;
 }
 
+/**
+ * @brief Unwraps the result of InstanceId allocation and logs errors.
+ *
+ * Logs errors if present, but always returns the original result so the caller
+ * can choose to handle the error (return, throw, etc).
+ *
+ * @tparam T      Instance ID value type.
+ * @param[in] result  The result from InstanceIdDb::next().
+ * @return std::expected<T, InstanceIdError>   The original result, value or error.
+ */
+template <typename T>
+std::expected<T, pldm::InstanceIdError>
+getInstanceId(const std::expected<T, pldm::InstanceIdError>& result)
+{
+    if (!result)
+    {
+        std::cerr << result.error().msg() << std::endl;
+    }
+    return result;
+}
+
 struct DBusMapping
 {
     std::string objectPath;   //!< D-Bus object path
diff --git a/fw-update/device_updater.cpp b/fw-update/device_updater.cpp
index f61428b..e3ce308 100644
--- a/fw-update/device_updater.cpp
+++ b/fw-update/device_updater.cpp
@@ -19,7 +19,16 @@ namespace fw_update
 
 void DeviceUpdater::startFwUpdateFlow()
 {
-    auto instanceId = updateManager->instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(updateManager->instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        // TODO: Errors from instanceIdDb.next() are currently handled by early return.
+        //       This temporarily suppresses error propagation and may silently discard failures.
+        //       The error handling here should be refactored to propagate and handle errors explicitly.
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     // NumberOfComponents
     const auto& applicableComponents =
         std::get<ApplicableComponents>(fwDeviceIDRecord);
@@ -114,7 +123,16 @@ void DeviceUpdater::sendPassCompTableRequest(size_t offset)
 {
     pldmRequest.reset();
 
-    auto instanceId = updateManager->instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(updateManager->instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        // TODO: Errors from instanceIdDb.next() are currently handled by early return.
+        //       This temporarily suppresses error propagation and may silently discard failures.
+        //       The error handling here should be refactored to propagate and handle errors explicitly.
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     // TransferFlag
     const auto& applicableComponents =
         std::get<ApplicableComponents>(fwDeviceIDRecord);
@@ -265,7 +283,16 @@ void DeviceUpdater::sendUpdateComponentRequest(size_t offset)
 {
     pldmRequest.reset();
 
-    auto instanceId = updateManager->instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(updateManager->instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        // TODO: Errors from instanceIdDb.next() are currently handled by early return.
+        //       This temporarily suppresses error propagation and may silently discard failures.
+        //       The error handling here should be refactored to propagate and handle errors explicitly.
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     const auto& applicableComponents =
         std::get<ApplicableComponents>(fwDeviceIDRecord);
     const auto& comp = compImageInfos[applicableComponents[offset]];
@@ -710,7 +737,17 @@ Response DeviceUpdater::applyComplete(const pldm_msg* request,
 void DeviceUpdater::sendActivateFirmwareRequest()
 {
     pldmRequest.reset();
-    auto instanceId = updateManager->instanceIdDb.next(eid);
+
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(updateManager->instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        // TODO: Errors from instanceIdDb.next() are currently handled by early return.
+        //       This temporarily suppresses error propagation and may silently discard failures.
+        //       The error handling here should be refactored to propagate and handle errors explicitly.
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     Request request(
         sizeof(pldm_msg_hdr) + sizeof(struct pldm_activate_firmware_req));
     auto requestMsg = new (request.data()) pldm_msg;
@@ -781,7 +818,17 @@ void DeviceUpdater::activateFirmware(mctp_eid_t eid, const pldm_msg* response,
 void DeviceUpdater::sendCancelUpdateComponentRequest()
 {
     pldmRequest.reset();
-    auto instanceId = updateManager->instanceIdDb.next(eid);
+
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(updateManager->instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        // TODO: Errors from instanceIdDb.next() are currently handled by early return.
+        //       This temporarily suppresses error propagation and may silently discard failures.
+        //       The error handling here should be refactored to propagate and handle errors explicitly.
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     Request request(sizeof(pldm_msg_hdr));
     auto requestMsg = new (request.data()) pldm_msg;
 
diff --git a/fw-update/inventory_manager.cpp b/fw-update/inventory_manager.cpp
index 38e8392..31c1552 100644
--- a/fw-update/inventory_manager.cpp
+++ b/fw-update/inventory_manager.cpp
@@ -34,7 +34,16 @@ void InventoryManager::discoverFDs(const std::vector<mctp_eid_t>& eids)
 
 void InventoryManager::sendQueryDeviceIdentifiersRequest(mctp_eid_t eid)
 {
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        // TODO: Errors from instanceIdDb.next() are currently handled by early return.
+        //       This temporarily suppresses error propagation and may silently discard failures.
+        //       The error handling here should be refactored to propagate and handle errors explicitly.
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     Request requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_QUERY_DEVICE_IDENTIFIERS_REQ_BYTES);
     auto request = new (requestMsg.data()) pldm_msg;
@@ -170,7 +179,16 @@ void InventoryManager::queryDeviceIdentifiers(
 void InventoryManager::sendQueryDownstreamDevicesRequest(mctp_eid_t eid)
 {
     Request requestMsg(sizeof(pldm_msg_hdr));
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        // TODO: Errors from instanceIdDb.next() are currently handled by early return.
+        //       This temporarily suppresses error propagation and may silently discard failures.
+        //       The error handling here should be refactored to propagate and handle errors explicitly.
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     auto request = new (requestMsg.data()) pldm_msg;
     auto rc = encode_query_downstream_devices_req(instanceId, request);
     if (rc)
@@ -277,7 +295,16 @@ void InventoryManager::sendQueryDownstreamIdentifiersRequest(
     mctp_eid_t eid, uint32_t dataTransferHandle,
     enum transfer_op_flag transferOperationFlag)
 {
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        // TODO: Errors from instanceIdDb.next() are currently handled by early return.
+        //       This temporarily suppresses error propagation and may silently discard failures.
+        //       The error handling here should be refactored to propagate and handle errors explicitly.
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     Request requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_QUERY_DOWNSTREAM_IDENTIFIERS_REQ_BYTES);
     auto request = new (requestMsg.data()) pldm_msg;
@@ -453,7 +480,16 @@ void InventoryManager::sendGetDownstreamFirmwareParametersRequest(
 {
     Request requestMsg(sizeof(pldm_msg_hdr) +
                        PLDM_GET_DOWNSTREAM_FIRMWARE_PARAMETERS_REQ_BYTES);
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        // TODO: Errors from instanceIdDb.next() are currently handled by early return.
+        //       This temporarily suppresses error propagation and may silently discard failures.
+        //       The error handling here should be refactored to propagate and handle errors explicitly.
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     auto request = new (requestMsg.data()) pldm_msg;
     pldm_get_downstream_firmware_parameters_req requestParameters{
         dataTransferHandle, static_cast<uint8_t>(transferOperationFlag)};
@@ -546,7 +582,16 @@ void InventoryManager::getDownstreamFirmwareParameters(
 
 void InventoryManager::sendGetFirmwareParametersRequest(mctp_eid_t eid)
 {
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        // TODO: Errors from instanceIdDb.next() are currently handled by early return.
+        //       This temporarily suppresses error propagation and may silently discard failures.
+        //       The error handling here should be refactored to propagate and handle errors explicitly.
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     Request requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_GET_FIRMWARE_PARAMETERS_REQ_BYTES);
     auto request = new (requestMsg.data()) pldm_msg;
diff --git a/host-bmc/dbus_to_event_handler.cpp b/host-bmc/dbus_to_event_handler.cpp
index 6149050..3c82cef 100644
--- a/host-bmc/dbus_to_event_handler.cpp
+++ b/host-bmc/dbus_to_event_handler.cpp
@@ -27,7 +27,13 @@ DbusToPLDMEvent::DbusToPLDMEvent(
 void DbusToPLDMEvent::sendEventMsg(uint8_t eventType,
                                    const std::vector<uint8_t>& eventDataVec)
 {
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_PLATFORM_EVENT_MESSAGE_MIN_REQ_BYTES +
         eventDataVec.size());
diff --git a/host-bmc/host_pdr_handler.cpp b/host-bmc/host_pdr_handler.cpp
index 61b4ccb..d4f4622 100644
--- a/host-bmc/host_pdr_handler.cpp
+++ b/host-bmc/host_pdr_handler.cpp
@@ -189,7 +189,13 @@ void HostPDRHandler::getHostPDR(uint32_t nextRecordHandle)
     {
         recordHandle = nextRecordHandle;
     }
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
 
     auto rc =
         encode_get_pdr_req(instanceId, recordHandle, 0, PLDM_GET_FIRSTPART,
@@ -388,7 +394,13 @@ void HostPDRHandler::sendPDRRepositoryChgEvent(std::vector<uint8_t>&& pdrTypes,
             "RC", rc);
         return;
     }
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_PLATFORM_EVENT_MESSAGE_MIN_REQ_BYTES +
         actualSize);
@@ -715,7 +727,13 @@ void HostPDRHandler::_processFetchPDREvent(
 void HostPDRHandler::setHostFirmwareCondition()
 {
     responseReceived = false;
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_GET_VERSION_REQ_BYTES);
     auto request = new (requestMsg.data()) pldm_msg;
@@ -787,7 +805,13 @@ void HostPDRHandler::setHostSensorState(const PDRList& stateSensorPDRs)
                 sensorRearm.byte = 0;
                 uint8_t tid = std::get<0>(terminusInfo);
 
-                auto instanceId = instanceIdDb.next(mctp_eid);
+                auto instanceIdResult = pldm::utils::getInstanceId(
+                    instanceIdDb.next(mctp_eid));
+                if (!instanceIdResult)
+                {
+                    return;
+                }
+                auto instanceId = instanceIdResult.value();
                 std::vector<uint8_t> requestMsg(
                     sizeof(pldm_msg_hdr) +
                     PLDM_GET_STATE_SENSOR_READINGS_REQ_BYTES);
@@ -929,7 +953,13 @@ void HostPDRHandler::setHostSensorState(const PDRList& stateSensorPDRs)
 void HostPDRHandler::getFRURecordTableMetadataByRemote(
     const PDRList& fruRecordSetPDRs)
 {
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_GET_FRU_RECORD_TABLE_METADATA_REQ_BYTES);
 
@@ -1007,7 +1037,13 @@ void HostPDRHandler::getFRURecordTableByRemote(const PDRList& fruRecordSetPDRs,
         return;
     }
 
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_GET_FRU_RECORD_TABLE_REQ_BYTES);
 
diff --git a/libpldmresponder/platform.cpp b/libpldmresponder/platform.cpp
index 7a3b63c..d6ee93b 100644
--- a/libpldmresponder/platform.cpp
+++ b/libpldmresponder/platform.cpp
@@ -980,7 +980,13 @@ void Handler::setEventReceiver()
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_SET_EVENT_RECEIVER_REQ_BYTES);
     auto request = new (requestMsg.data()) pldm_msg;
-    auto instanceId = instanceIdDb->next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb->next(eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     uint8_t eventMessageGlobalEnable =
         PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_ASYNC_KEEP_ALIVE;
     uint8_t transportProtocolType = PLDM_TRANSPORT_PROTOCOL_TYPE_MCTP;
diff --git a/oem/ibm/host-bmc/host_lamp_test.cpp b/oem/ibm/host-bmc/host_lamp_test.cpp
index e7485d8..1dda9f2 100644
--- a/oem/ibm/host-bmc/host_lamp_test.cpp
+++ b/oem/ibm/host-bmc/host_lamp_test.cpp
@@ -109,7 +109,13 @@ uint16_t HostLampTest::getEffecterID()
 uint8_t HostLampTest::setHostStateEffecter(uint16_t effecterID)
 {
     constexpr uint8_t effecterCount = 1;
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return PLDM_ERROR;
+    }
+    auto instanceId = instanceIdResult.value();
 
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + sizeof(effecterID) + sizeof(effecterCount) +
diff --git a/oem/ibm/libpldmresponder/oem_ibm_handler.cpp b/oem/ibm/libpldmresponder/oem_ibm_handler.cpp
index decb953..34e6d70 100644
--- a/oem/ibm/libpldmresponder/oem_ibm_handler.cpp
+++ b/oem/ibm/libpldmresponder/oem_ibm_handler.cpp
@@ -524,7 +524,13 @@ void pldm::responder::oem_ibm_platform::Handler::sendStateSensorEvent(
     eventClass->sensor_offset = sensorOffset;
     eventClass->event_state = eventState;
     eventClass->previous_event_state = prevEventState;
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_PLATFORM_EVENT_MESSAGE_MIN_REQ_BYTES +
         sensorEventDataVec.size());
diff --git a/oem/ibm/libpldmresponder/platform_oem_ibm.cpp b/oem/ibm/libpldmresponder/platform_oem_ibm.cpp
index 47c1e53..9733775 100644
--- a/oem/ibm/libpldmresponder/platform_oem_ibm.cpp
+++ b/oem/ibm/libpldmresponder/platform_oem_ibm.cpp
@@ -61,7 +61,13 @@ int sendBiosAttributeUpdateEvent(
             "ERROR", e);
     }
 
-    auto instanceId = instanceIdDb->next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb->next(eid));
+    if (!instanceIdResult)
+    {
+        return PLDM_ERROR;
+    }
+    auto instanceId = instanceIdResult.value();
 
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + sizeof(pldm_bios_attribute_update_event_req) -
diff --git a/oem/ibm/requester/dbus_to_file_handler.cpp b/oem/ibm/requester/dbus_to_file_handler.cpp
index 6ca2975..8bc25af 100644
--- a/oem/ibm/requester/dbus_to_file_handler.cpp
+++ b/oem/ibm/requester/dbus_to_file_handler.cpp
@@ -40,7 +40,13 @@ void DbusToFileHandler::sendNewFileAvailableCmd(uint64_t fileSize)
             "xyz.openbmc_project.bmc.pldm.InternalFailure");
         return;
     }
-    auto instanceId = instanceIdDb->next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb->next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_NEW_FILE_REQ_BYTES);
     auto request = reinterpret_cast<pldm_msg*>(requestMsg.data());
@@ -252,7 +258,13 @@ void DbusToFileHandler::newFileAvailableSendToHost(
             "xyz.openbmc_project.bmc.pldm.InternalFailure");
         return;
     }
-    auto instanceId = instanceIdDb->next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb->next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_NEW_FILE_REQ_BYTES);
     auto request = reinterpret_cast<pldm_msg*>(requestMsg.data());
diff --git a/platform-mc/dbus_to_terminus_effecters.cpp b/platform-mc/dbus_to_terminus_effecters.cpp
index 0c27f95..594e3c4 100644
--- a/platform-mc/dbus_to_terminus_effecters.cpp
+++ b/platform-mc/dbus_to_terminus_effecters.cpp
@@ -481,7 +481,13 @@ int HostEffecterParser::setTerminusNumericEffecter(
         }
     }
 
-    auto instanceId = instanceIdDb->next(mctpEid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb->next(mctpEid));
+    if (!instanceIdResult)
+    {
+        return PLDM_ERROR;
+    }
+    auto instanceId = instanceIdResult.value();
     int rc = PLDM_ERROR;
     std::vector<uint8_t> requestMsg;
 
@@ -620,7 +626,13 @@ int HostEffecterParser::setHostStateEffecter(
     }
 
     uint8_t& compEffCnt = hostEffecterInfo[effecterInfoIndex].compEffecterCnt;
-    auto instanceId = instanceIdDb->next(mctpEid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb->next(mctpEid));
+    if (!instanceIdResult)
+    {
+        return PLDM_ERROR;
+    }
+    auto instanceId = instanceIdResult.value();
 
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + sizeof(effecterId) + sizeof(compEffCnt) +
diff --git a/platform-mc/terminus_manager.cpp b/platform-mc/terminus_manager.cpp
index 406c70a..66119ed 100644
--- a/platform-mc/terminus_manager.cpp
+++ b/platform-mc/terminus_manager.cpp
@@ -442,7 +442,13 @@ exec::task<int> TerminusManager::sendRecvPldmMsgOverMctp(
 
 exec::task<int> TerminusManager::getTidOverMctp(mctp_eid_t eid, pldm_tid_t* tid)
 {
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        co_return PLDM_ERROR;
+    }
+    auto instanceId = instanceIdResult.value();
     Request request(sizeof(pldm_msg_hdr));
     auto requestMsg = new (request.data()) pldm_msg;
     auto rc = encode_get_tid_req(instanceId, requestMsg);
@@ -488,7 +494,13 @@ exec::task<int> TerminusManager::getTidOverMctp(mctp_eid_t eid, pldm_tid_t* tid)
 
 exec::task<int> TerminusManager::setTidOverMctp(mctp_eid_t eid, pldm_tid_t tid)
 {
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        co_return PLDM_ERROR;
+    }
+    auto instanceId = instanceIdResult.value();
     Request request(sizeof(pldm_msg_hdr) + sizeof(pldm_set_tid_req));
     auto requestMsg = new (request.data()) pldm_msg;
     auto rc = encode_set_tid_req(instanceId, tid, requestMsg);
@@ -662,7 +674,13 @@ exec::task<int> TerminusManager::sendRecvPldmMsg(
 
     auto eid = std::get<0>(mctpInfo.value());
     auto requestMsg = new (request.data()) pldm_msg;
-    requestMsg->hdr.instance_id = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    if (!instanceIdResult)
+    {
+        co_return PLDM_ERROR;
+    }
+    requestMsg->hdr.instance_id = instanceIdResult.value();
     auto rc = co_await sendRecvPldmMsgOverMctp(eid, request, responseMsg,
                                                responseLen);
 
diff --git a/pldmtool/pldm_cmd_helper.cpp b/pldmtool/pldm_cmd_helper.cpp
index e488557..54260e7 100644
--- a/pldmtool/pldm_cmd_helper.cpp
+++ b/pldmtool/pldm_cmd_helper.cpp
@@ -89,7 +89,13 @@ void fillCompletionCode(uint8_t completionCode, ordered_json& data,
 
 void CommandInterface::exec()
 {
-    instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(mctp_eid));
+    if (!instanceIdResult)
+    {
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     auto [rc, requestMsg] = createRequestMsg();
     if (rc != PLDM_SUCCESS)
     {
diff --git a/requester/test/handler_test.cpp b/requester/test/handler_test.cpp
index caa4663..205248e 100644
--- a/requester/test/handler_test.cpp
+++ b/requester/test/handler_test.cpp
@@ -79,7 +79,10 @@ TEST_F(HandlerTest, singleRequestResponseScenario)
         pldmTransport, event, instanceIdDb, false, seconds(1), 2,
         milliseconds(100));
     pldm::Request request{};
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    ASSERT_TRUE(instanceIdResult);
+    auto instanceId = instanceIdResult.value();
     EXPECT_EQ(instanceId, 0);
     auto rc = reqHandler.registerRequest(
         eid, instanceId, 0, 0, std::move(request),
@@ -102,7 +105,10 @@ TEST_F(HandlerTest, singleRequestInstanceIdTimerExpired)
         pldmTransport, event, instanceIdDb, false, seconds(1), 2,
         milliseconds(100));
     pldm::Request request{};
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    ASSERT_TRUE(instanceIdResult);
+    auto instanceId = instanceIdResult.value();
     EXPECT_EQ(instanceId, 0);
     auto rc = reqHandler.registerRequest(
         eid, instanceId, 0, 0, std::move(request),
@@ -123,7 +129,10 @@ TEST_F(HandlerTest, multipleRequestResponseScenario)
         pldmTransport, event, instanceIdDb, false, seconds(2), 2,
         milliseconds(100));
     pldm::Request request{};
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    ASSERT_TRUE(instanceIdResult);
+    auto instanceId = instanceIdResult.value();
     EXPECT_EQ(instanceId, 0);
     auto rc = reqHandler.registerRequest(
         eid, instanceId, 0, 0, std::move(request),
@@ -133,7 +142,10 @@ TEST_F(HandlerTest, multipleRequestResponseScenario)
     EXPECT_EQ(rc, PLDM_SUCCESS);
 
     pldm::Request requestNxt{};
-    auto instanceIdNxt = instanceIdDb.next(eid);
+    auto instanceIdNxtResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    ASSERT_TRUE(instanceIdNxtResult);
+    auto instanceIdNxt = instanceIdResult.value();
     EXPECT_EQ(instanceIdNxt, 1);
     rc = reqHandler.registerRequest(
         eid, instanceIdNxt, 0, 0, std::move(requestNxt),
@@ -168,7 +180,10 @@ TEST_F(HandlerTest, singleRequestResponseScenarioUsingCoroutine)
         pldmTransport, event, instanceIdDb, false, seconds(1), 2,
         milliseconds(100));
 
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    ASSERT_TRUE(instanceIdResult);
+    auto instanceId = instanceIdResult.value();
     EXPECT_EQ(instanceId, 0);
 
     scope.spawn(
@@ -214,7 +229,10 @@ TEST_F(HandlerTest, singleRequestCancellationScenarioUsingCoroutine)
     Handler<NiceMock<MockRequest>> reqHandler(
         pldmTransport, event, instanceIdDb, false, seconds(1), 2,
         milliseconds(100));
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    ASSERT_TRUE(instanceIdResult);
+    auto instanceId = instanceIdResult.value();
     EXPECT_EQ(instanceId, 0);
 
     bool stopped = false;
@@ -271,7 +289,10 @@ TEST_F(HandlerTest, asyncRequestResponseByCoroutine)
     exec::async_scope scope;
     Handler<MockRequest> reqHandler(pldmTransport, event, instanceIdDb, false,
                                     seconds(1), 2, milliseconds(100));
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(eid));
+    ASSERT_TRUE(instanceIdResult);
+    auto instanceId = instanceIdResult.value();
 
     uint8_t expectedTid = 1;
 
diff --git a/softoff/softoff.cpp b/softoff/softoff.cpp
index 9721c7e..09a933c 100644
--- a/softoff/softoff.cpp
+++ b/softoff/softoff.cpp
@@ -271,7 +271,6 @@ int SoftPowerOff::hostSoftOff(sdeventplus::Event& event)
 {
     constexpr uint8_t effecterCount = 1;
     PldmTransport pldmTransport{};
-    uint8_t instanceID;
     uint8_t mctpEID;
 
     mctpEID = pldm::utils::readHostEID();
@@ -285,7 +284,13 @@ int SoftPowerOff::hostSoftOff(sdeventplus::Event& event)
     auto request = new (requestMsg.data()) pldm_msg;
     set_effecter_state_field stateField{
         PLDM_REQUEST_SET, PLDM_SW_TERM_GRACEFUL_SHUTDOWN_REQUESTED};
-    instanceID = instanceIdDb.next(pldmTID);
+    auto instanceIdResult =
+        pldm::utils::getInstanceId(instanceIdDb.next(pldmTID));
+    if (!instanceIdResult)
+    {
+        return PLDM_ERROR;
+    }
+    auto instanceID = *instanceIdResult.value();
     auto rc = encode_set_state_effecter_states_req(
         instanceID, effecterID, effecterCount, &stateField, request);
     if (rc != PLDM_SUCCESS)
-- 
2.43.0

