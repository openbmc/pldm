From 65bda1360dd771b8fcf8382b1f245a71f3e20d73 Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang.wiwynn@gmail.com>
Date: Thu, 8 May 2025 13:49:06 +0800
Subject: [PATCH] pldm: use std::expected for instance ID allocation

Refactor InstanceIdDb::next() to return
std::expected<uint8_t, InstanceIdError> instead of throwing exceptions.
This change enables callers to explicitly handle allocation errors via
value inspection, rather than relying on exception handling.

This approach prevents core dumps from uncaught exceptions and
eliminates the need for pervasive try-catch blocks.
Callers can now access the error code and message directly, improving
clarity and control of error propagation.

For functions that previously relied on exceptions for error
propagation, throwing is still used.
Future refactoring may convert these to explicit error returns as well.

Change-Id: Ibf2e0034b0ee725cb59adfd93b74e48db8c42cba
Signed-off-by: Eric Yang <eric.yang.wiwynn@gmail.com>
---
 common/instance_id.hpp                        |  71 +++++++-
 fw-update/device_updater.cpp                  | 155 +++++++++++++++---
 fw-update/device_updater.hpp                  |   8 +-
 fw-update/inventory_manager.cpp               |  71 +++++++-
 fw-update/update_manager.cpp                  |   9 +-
 host-bmc/dbus_to_event_handler.cpp            |  11 +-
 host-bmc/host_pdr_handler.cpp                 |  67 +++++++-
 libpldmresponder/platform.cpp                 |  11 +-
 oem/ibm/host-bmc/host_lamp_test.cpp           |  11 +-
 oem/ibm/libpldmresponder/oem_ibm_handler.cpp  |  11 +-
 oem/ibm/libpldmresponder/platform_oem_ibm.cpp |  11 +-
 oem/ibm/requester/dbus_to_file_handler.cpp    |  22 ++-
 platform-mc/dbus_to_terminus_effecters.cpp    |  22 ++-
 platform-mc/terminus_manager.cpp              |  34 +++-
 pldmtool/pldm_cmd_helper.cpp                  |  10 +-
 requester/test/handler_test.cpp               |  28 +++-
 softoff/softoff.cpp                           |  12 +-
 17 files changed, 489 insertions(+), 75 deletions(-)

diff --git a/common/instance_id.hpp b/common/instance_id.hpp
index 40de1f1..342134e 100644
--- a/common/instance_id.hpp
+++ b/common/instance_id.hpp
@@ -5,12 +5,70 @@
 #include <cerrno>
 #include <cstdint>
 #include <exception>
+#include <expected>
 #include <string>
 #include <system_error>
 
 namespace pldm
 {
 
+/**
+ * @class InstanceIdError
+ * @brief Exception for PLDM instance ID allocation and management errors.
+ */
+class InstanceIdError : public std::exception
+{
+  public:
+    InstanceIdError(const InstanceIdError&) noexcept = default;
+    InstanceIdError(InstanceIdError&&) noexcept = default;
+    InstanceIdError& operator=(const InstanceIdError&) noexcept = default;
+    InstanceIdError& operator=(InstanceIdError&&) noexcept = default;
+    ~InstanceIdError() noexcept override = default;
+
+    /** @brief Construct with an error code. */
+    explicit InstanceIdError(int rc) : rc_(rc), msg_(rcToMsg(rc)) {}
+
+    /** @brief Construct with an error code and message. */
+    InstanceIdError(int rc, const std::string& m) : rc_(rc), msg_(m) {}
+
+    /** @brief Construct with an error code and message. */
+    InstanceIdError(int rc, std::string&& m) : rc_(rc), msg_(std::move(m)) {}
+
+    /** @brief Get the error code. */
+    int rc() const noexcept
+    {
+        return rc_;
+    }
+
+    /** @brief Get the error message. */
+    const std::string& msg() const noexcept
+    {
+        return msg_;
+    }
+
+    /** @brief Convert an error code to a message. */
+    static std::string rcToMsg(int rc)
+    {
+        switch (rc)
+        {
+            case -EAGAIN:
+                return "No free instance ids";
+            default:
+                return std::system_category().message(rc);
+        }
+    }
+
+    /** @brief Get the error message (for std::exception). */
+    const char* what() const noexcept override
+    {
+        return msg_.c_str();
+    }
+
+  private:
+    int rc_;
+    std::string msg_;
+};
+
 /** @class InstanceId
  *  @brief Implementation of PLDM instance id as per DSP0240 v1.0.0
  */
@@ -53,22 +111,17 @@ class InstanceIdDb
 
     /** @brief Allocate an instance ID for the given terminus
      *  @param[in] tid - the terminus ID the instance ID is associated with
-     *  @return - PLDM instance id or -EAGAIN if there are no available instance
-     *            IDs
+     *  @return - PLDM instance id on success, or InstanceIdError if allocation
+     * fails
      */
-    uint8_t next(uint8_t tid)
+    std::expected<uint8_t, InstanceIdError> next(uint8_t tid)
     {
         uint8_t id;
         int rc = pldm_instance_id_alloc(pldmInstanceIdDb, tid, &id);
 
-        if (rc == -EAGAIN)
-        {
-            throw std::runtime_error("No free instance ids");
-        }
-
         if (rc)
         {
-            throw std::system_category().default_error_condition(rc);
+            return std::unexpected(InstanceIdError{rc});
         }
 
         return id;
diff --git a/fw-update/device_updater.cpp b/fw-update/device_updater.cpp
index 77412b9..97cacf9 100644
--- a/fw-update/device_updater.cpp
+++ b/fw-update/device_updater.cpp
@@ -17,9 +17,18 @@ namespace pldm
 namespace fw_update
 {
 
-void DeviceUpdater::startFwUpdateFlow()
+int DeviceUpdater::startFwUpdateFlow()
 {
-    auto instanceId = updateManager->instanceIdDb.next(eid);
+    auto instanceIdResult = updateManager->instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return instanceIdResult.error().rc();
+    }
+    auto instanceId = instanceIdResult.value();
     // NumberOfComponents
     const auto& applicableComponents =
         std::get<ApplicableComponents>(fwDeviceIDRecord);
@@ -53,6 +62,7 @@ void DeviceUpdater::startFwUpdateFlow()
         error(
             "Failed to encode request update request for endpoint ID '{EID}', response code '{RC}'",
             "EID", eid, "RC", rc);
+        return rc;
     }
 
     rc = updateManager->handler.registerRequest(
@@ -66,7 +76,10 @@ void DeviceUpdater::startFwUpdateFlow()
         error(
             "Failed to send request update for endpoint ID '{EID}', response code '{RC}'",
             "EID", eid, "RC", rc);
+        return rc;
     }
+
+    return PLDM_SUCCESS;
 }
 
 void DeviceUpdater::requestUpdate(mctp_eid_t eid, const pldm_msg* response,
@@ -102,17 +115,34 @@ void DeviceUpdater::requestUpdate(mctp_eid_t eid, const pldm_msg* response,
     }
 
     // Optional fields DeviceMetaData and GetPackageData not handled
-    pldmRequest = std::make_unique<sdeventplus::source::Defer>(
-        updateManager->event,
-        std::bind(&DeviceUpdater::sendPassCompTableRequest, this,
-                  componentIndex));
+    pldmRequest = std::make_unique<
+        sdeventplus::source::
+            Defer>(updateManager->event, [this](
+                                             sdeventplus::source::EventBase&) {
+        int rc = this->sendPassCompTableRequest(this->componentIndex);
+        if (rc)
+        {
+            error(
+                "Failed to send pass component table request for endpoint ID '{EID}', response code '{RC}'",
+                "EID", this->eid, "RC", rc);
+        }
+    });
 }
 
-void DeviceUpdater::sendPassCompTableRequest(size_t offset)
+int DeviceUpdater::sendPassCompTableRequest(size_t offset)
 {
     pldmRequest.reset();
 
-    auto instanceId = updateManager->instanceIdDb.next(eid);
+    auto instanceIdResult = updateManager->instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return instanceIdResult.error().rc();
+    }
+    auto instanceId = instanceIdResult.value();
     // TransferFlag
     const auto& applicableComponents =
         std::get<ApplicableComponents>(fwDeviceIDRecord);
@@ -155,6 +185,7 @@ void DeviceUpdater::sendPassCompTableRequest(size_t offset)
         error(
             "Failed to find component classification '{CLASSIFICATION}' and identifier '{IDENTIFIER}'",
             "CLASSIFICATION", compClassification, "IDENTIFIER", compIdentifier);
+        return PLDM_ERROR;
     }
     // ComponentComparisonStamp
     CompComparisonStamp compComparisonStamp = std::get<static_cast<size_t>(
@@ -183,6 +214,7 @@ void DeviceUpdater::sendPassCompTableRequest(size_t offset)
         error(
             "Failed to encode pass component table req for endpoint ID '{EID}', response code '{RC}'",
             "EID", eid, "RC", rc);
+        return rc;
     }
 
     rc = updateManager->handler.registerRequest(
@@ -197,7 +229,10 @@ void DeviceUpdater::sendPassCompTableRequest(size_t offset)
         error(
             "Failed to send pass component table request for endpoint ID '{EID}', response code '{RC}'",
             "EID", eid, "RC", rc);
+        return rc;
     }
+
+    return PLDM_SUCCESS;
 }
 
 void DeviceUpdater::passCompTable(mctp_eid_t eid, const pldm_msg* response,
@@ -242,26 +277,54 @@ void DeviceUpdater::passCompTable(mctp_eid_t eid, const pldm_msg* response,
     if (componentIndex == applicableComponents.size() - 1)
     {
         componentIndex = 0;
-        pldmRequest = std::make_unique<sdeventplus::source::Defer>(
-            updateManager->event,
-            std::bind(&DeviceUpdater::sendUpdateComponentRequest, this,
-                      componentIndex));
+        pldmRequest = std::make_unique<
+            sdeventplus::source::
+                Defer>(updateManager->event, [this](sdeventplus::source::
+                                                        EventBase&) {
+            int rc = this->sendActivateFirmwareRequest();
+            if (rc)
+            {
+                error(
+                    "Failed to send ActivateFirmware request for endpoint ID '{EID}', error code '{RC}'",
+                    "EID", this->eid, "RC", rc);
+                return;
+            }
+        });
     }
     else
     {
         componentIndex++;
-        pldmRequest = std::make_unique<sdeventplus::source::Defer>(
-            updateManager->event,
-            std::bind(&DeviceUpdater::sendPassCompTableRequest, this,
-                      componentIndex));
+        pldmRequest = std::make_unique<
+            sdeventplus::source::
+                Defer>(updateManager->event, [this, idx = componentIndex](
+                                                 sdeventplus::source::
+                                                     EventBase&) {
+            int rc = this->sendUpdateComponentRequest(idx);
+            if (rc)
+            {
+                error(
+                    "Failed to send UpdateComponent request for endpoint ID '{EID}', component index '{INDEX}', error code '{RC}'",
+                    "EID", this->eid, "INDEX", idx, "RC", rc);
+                return;
+            }
+        });
     }
 }
 
-void DeviceUpdater::sendUpdateComponentRequest(size_t offset)
+int DeviceUpdater::sendUpdateComponentRequest(size_t offset)
 {
     pldmRequest.reset();
 
-    auto instanceId = updateManager->instanceIdDb.next(eid);
+    auto instanceIdResult = updateManager->instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return instanceIdResult.error().rc();
+    }
+    auto instanceId = instanceIdResult.value();
     const auto& applicableComponents =
         std::get<ApplicableComponents>(fwDeviceIDRecord);
     const auto& comp = compImageInfos[applicableComponents[offset]];
@@ -286,6 +349,7 @@ void DeviceUpdater::sendUpdateComponentRequest(size_t offset)
         error(
             "Failed to find component classification '{CLASSIFICATION}' and identifier '{IDENTIFIER}'",
             "CLASSIFICATION", compClassification, "IDENTIFIER", compIdentifier);
+        return PLDM_ERROR;
     }
 
     // UpdateOptionFlags
@@ -317,6 +381,7 @@ void DeviceUpdater::sendUpdateComponentRequest(size_t offset)
         error(
             "Failed to encode update component req for endpoint ID '{EID}', response code '{RC}'",
             "EID", eid, "RC", rc);
+        return rc;
     }
 
     rc = updateManager->handler.registerRequest(
@@ -330,7 +395,10 @@ void DeviceUpdater::sendUpdateComponentRequest(size_t offset)
         error(
             "Failed to send update request for endpoint ID '{EID}', response code '{RC}'",
             "EID", eid, "RC", rc);
+        return rc;
     }
+
+    return PLDM_SUCCESS;
 }
 
 void DeviceUpdater::updateComponent(mctp_eid_t eid, const pldm_msg* response,
@@ -638,26 +706,55 @@ Response DeviceUpdater::applyComplete(const pldm_msg* request,
     if (componentIndex == applicableComponents.size() - 1)
     {
         componentIndex = 0;
-        pldmRequest = std::make_unique<sdeventplus::source::Defer>(
-            updateManager->event,
-            std::bind(&DeviceUpdater::sendActivateFirmwareRequest, this));
+        pldmRequest = std::make_unique<
+            sdeventplus::source::
+                Defer>(updateManager->event, [this](sdeventplus::source::
+                                                        EventBase&) {
+            int rc = this->sendActivateFirmwareRequest();
+            if (rc)
+            {
+                error(
+                    "Failed to send ActivateFirmware request for endpoint ID '{EID}', error code '{RC}'",
+                    "EID", this->eid, "RC", rc);
+                return;
+            }
+        });
     }
     else
     {
         componentIndex++;
-        pldmRequest = std::make_unique<sdeventplus::source::Defer>(
-            updateManager->event,
-            std::bind(&DeviceUpdater::sendUpdateComponentRequest, this,
-                      componentIndex));
+        pldmRequest = std::make_unique<
+            sdeventplus::source::
+                Defer>(updateManager->event, [this, idx = componentIndex](
+                                                 sdeventplus::source::
+                                                     EventBase&) {
+            int rc = this->sendUpdateComponentRequest(idx);
+            if (rc)
+            {
+                error(
+                    "Failed to send UpdateComponent request for endpoint ID '{EID}', component index '{INDEX}', error code '{RC}'",
+                    "EID", this->eid, "INDEX", idx, "RC", rc);
+                return;
+            }
+        });
     }
 
     return response;
 }
 
-void DeviceUpdater::sendActivateFirmwareRequest()
+int DeviceUpdater::sendActivateFirmwareRequest()
 {
     pldmRequest.reset();
-    auto instanceId = updateManager->instanceIdDb.next(eid);
+    auto instanceIdResult = updateManager->instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return instanceIdResult.error().rc();
+    }
+    auto instanceId = instanceIdResult.value();
     Request request(
         sizeof(pldm_msg_hdr) + sizeof(struct pldm_activate_firmware_req));
     auto requestMsg = new (request.data()) pldm_msg;
@@ -671,6 +768,7 @@ void DeviceUpdater::sendActivateFirmwareRequest()
         error(
             "Failed to encode activate firmware req for endpoint ID '{EID}', response code '{RC}'",
             "EID", eid, "RC", rc);
+        return rc;
     }
 
     rc = updateManager->handler.registerRequest(
@@ -683,7 +781,10 @@ void DeviceUpdater::sendActivateFirmwareRequest()
         error(
             "Failed to send activate firmware request for endpoint ID '{EID}', response code '{RC}'",
             "EID", eid, "RC", rc);
+        return rc;
     }
+
+    return PLDM_SUCCESS;
 }
 
 void DeviceUpdater::activateFirmware(mctp_eid_t eid, const pldm_msg* response,
diff --git a/fw-update/device_updater.hpp b/fw-update/device_updater.hpp
index 4613a7c..084e3a8 100644
--- a/fw-update/device_updater.hpp
+++ b/fw-update/device_updater.hpp
@@ -63,7 +63,7 @@ class DeviceUpdater
      *  To start the update flow RequestUpdate command is sent to the FD.
      *
      */
-    void startFwUpdateFlow();
+    int startFwUpdateFlow();
 
     /** @brief Handler for RequestUpdate command response
      *
@@ -158,16 +158,16 @@ class DeviceUpdater
      *
      *  @param[in] compOffset - component offset in compImageInfos
      */
-    void sendPassCompTableRequest(size_t offset);
+    int sendPassCompTableRequest(size_t offset);
 
     /** @brief Send UpdateComponent command request
      *
      *  @param[in] compOffset - component offset in compImageInfos
      */
-    void sendUpdateComponentRequest(size_t offset);
+    int sendUpdateComponentRequest(size_t offset);
 
     /** @brief Send ActivateFirmware command request */
-    void sendActivateFirmwareRequest();
+    int sendActivateFirmwareRequest();
 
     /** @brief Endpoint ID of the firmware device */
     mctp_eid_t eid;
diff --git a/fw-update/inventory_manager.cpp b/fw-update/inventory_manager.cpp
index 38e8392..4f35701 100644
--- a/fw-update/inventory_manager.cpp
+++ b/fw-update/inventory_manager.cpp
@@ -34,7 +34,20 @@ void InventoryManager::discoverFDs(const std::vector<mctp_eid_t>& eids)
 
 void InventoryManager::sendQueryDeviceIdentifiersRequest(mctp_eid_t eid)
 {
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        // This function and its callers use exceptions for error propagation.
+        // To maintain consistent error handling, we throw here.
+        // If/when the codebase is refactored for explicit error returns,
+        // this should be changed accordingly.
+        throw InstanceIdError(instanceIdResult.error());
+    }
+    auto instanceId = instanceIdResult.value();
     Request requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_QUERY_DEVICE_IDENTIFIERS_REQ_BYTES);
     auto request = new (requestMsg.data()) pldm_msg;
@@ -170,7 +183,20 @@ void InventoryManager::queryDeviceIdentifiers(
 void InventoryManager::sendQueryDownstreamDevicesRequest(mctp_eid_t eid)
 {
     Request requestMsg(sizeof(pldm_msg_hdr));
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        // This function and its callers use exceptions for error propagation.
+        // To maintain consistent error handling, we throw here.
+        // If/when the codebase is refactored for explicit error returns,
+        // this should be changed accordingly.
+        throw InstanceIdError(instanceIdResult.error());
+    }
+    auto instanceId = instanceIdResult.value();
     auto request = new (requestMsg.data()) pldm_msg;
     auto rc = encode_query_downstream_devices_req(instanceId, request);
     if (rc)
@@ -277,7 +303,20 @@ void InventoryManager::sendQueryDownstreamIdentifiersRequest(
     mctp_eid_t eid, uint32_t dataTransferHandle,
     enum transfer_op_flag transferOperationFlag)
 {
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        // This function and its callers use exceptions for error propagation.
+        // To maintain consistent error handling, we throw here.
+        // If/when the codebase is refactored for explicit error returns,
+        // this should be changed accordingly.
+        throw InstanceIdError(instanceIdResult.error());
+    }
+    auto instanceId = instanceIdResult.value();
     Request requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_QUERY_DOWNSTREAM_IDENTIFIERS_REQ_BYTES);
     auto request = new (requestMsg.data()) pldm_msg;
@@ -453,7 +492,20 @@ void InventoryManager::sendGetDownstreamFirmwareParametersRequest(
 {
     Request requestMsg(sizeof(pldm_msg_hdr) +
                        PLDM_GET_DOWNSTREAM_FIRMWARE_PARAMETERS_REQ_BYTES);
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        // This function and its callers use exceptions for error propagation.
+        // To maintain consistent error handling, we throw here.
+        // If/when the codebase is refactored for explicit error returns,
+        // this should be changed accordingly.
+        throw InstanceIdError(instanceIdResult.error());
+    }
+    auto instanceId = instanceIdResult.value();
     auto request = new (requestMsg.data()) pldm_msg;
     pldm_get_downstream_firmware_parameters_req requestParameters{
         dataTransferHandle, static_cast<uint8_t>(transferOperationFlag)};
@@ -546,7 +598,16 @@ void InventoryManager::getDownstreamFirmwareParameters(
 
 void InventoryManager::sendGetFirmwareParametersRequest(mctp_eid_t eid)
 {
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     Request requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_GET_FIRMWARE_PARAMETERS_REQ_BYTES);
     auto request = new (requestMsg.data()) pldm_msg;
diff --git a/fw-update/update_manager.cpp b/fw-update/update_manager.cpp
index 66539d5..083789b 100644
--- a/fw-update/update_manager.cpp
+++ b/fw-update/update_manager.cpp
@@ -263,7 +263,14 @@ void UpdateManager::activatePackage()
     startTime = std::chrono::steady_clock::now();
     for (const auto& [eid, deviceUpdaterPtr] : deviceUpdaterMap)
     {
-        deviceUpdaterPtr->startFwUpdateFlow();
+        auto rc = deviceUpdaterPtr->startFwUpdateFlow();
+        if (rc)
+        {
+            error(
+                "Failed to start firmware update flow for endpoint ID {EID} with response code {RC}",
+                "EID", eid, "RC", rc);
+            continue;
+        }
     }
 }
 
diff --git a/host-bmc/dbus_to_event_handler.cpp b/host-bmc/dbus_to_event_handler.cpp
index 6149050..da3c073 100644
--- a/host-bmc/dbus_to_event_handler.cpp
+++ b/host-bmc/dbus_to_event_handler.cpp
@@ -27,7 +27,16 @@ DbusToPLDMEvent::DbusToPLDMEvent(
 void DbusToPLDMEvent::sendEventMsg(uint8_t eventType,
                                    const std::vector<uint8_t>& eventDataVec)
 {
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult = instanceIdDb.next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctp_eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_PLATFORM_EVENT_MESSAGE_MIN_REQ_BYTES +
         eventDataVec.size());
diff --git a/host-bmc/host_pdr_handler.cpp b/host-bmc/host_pdr_handler.cpp
index 61b4ccb..b517a1e 100644
--- a/host-bmc/host_pdr_handler.cpp
+++ b/host-bmc/host_pdr_handler.cpp
@@ -189,7 +189,16 @@ void HostPDRHandler::getHostPDR(uint32_t nextRecordHandle)
     {
         recordHandle = nextRecordHandle;
     }
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult = instanceIdDb.next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctp_eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
 
     auto rc =
         encode_get_pdr_req(instanceId, recordHandle, 0, PLDM_GET_FIRSTPART,
@@ -388,7 +397,16 @@ void HostPDRHandler::sendPDRRepositoryChgEvent(std::vector<uint8_t>&& pdrTypes,
             "RC", rc);
         return;
     }
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult = instanceIdDb.next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctp_eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_PLATFORM_EVENT_MESSAGE_MIN_REQ_BYTES +
         actualSize);
@@ -715,7 +733,16 @@ void HostPDRHandler::_processFetchPDREvent(
 void HostPDRHandler::setHostFirmwareCondition()
 {
     responseReceived = false;
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult = instanceIdDb.next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctp_eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_GET_VERSION_REQ_BYTES);
     auto request = new (requestMsg.data()) pldm_msg;
@@ -787,7 +814,16 @@ void HostPDRHandler::setHostSensorState(const PDRList& stateSensorPDRs)
                 sensorRearm.byte = 0;
                 uint8_t tid = std::get<0>(terminusInfo);
 
-                auto instanceId = instanceIdDb.next(mctp_eid);
+                auto instanceIdResult = instanceIdDb.next(mctp_eid);
+                if (!instanceIdResult)
+                {
+                    error(
+                        "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+                        "EID", mctp_eid, "RC", instanceIdResult.error().rc(),
+                        "MSG", instanceIdResult.error().msg());
+                    return;
+                }
+                auto instanceId = instanceIdResult.value();
                 std::vector<uint8_t> requestMsg(
                     sizeof(pldm_msg_hdr) +
                     PLDM_GET_STATE_SENSOR_READINGS_REQ_BYTES);
@@ -929,7 +965,16 @@ void HostPDRHandler::setHostSensorState(const PDRList& stateSensorPDRs)
 void HostPDRHandler::getFRURecordTableMetadataByRemote(
     const PDRList& fruRecordSetPDRs)
 {
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult = instanceIdDb.next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctp_eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_GET_FRU_RECORD_TABLE_METADATA_REQ_BYTES);
 
@@ -1006,8 +1051,16 @@ void HostPDRHandler::getFRURecordTableByRemote(const PDRList& fruRecordSetPDRs,
         error("Failed to get fru record table");
         return;
     }
-
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult = instanceIdDb.next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctp_eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_GET_FRU_RECORD_TABLE_REQ_BYTES);
 
diff --git a/libpldmresponder/platform.cpp b/libpldmresponder/platform.cpp
index 7a3b63c..28afc37 100644
--- a/libpldmresponder/platform.cpp
+++ b/libpldmresponder/platform.cpp
@@ -980,7 +980,16 @@ void Handler::setEventReceiver()
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_SET_EVENT_RECEIVER_REQ_BYTES);
     auto request = new (requestMsg.data()) pldm_msg;
-    auto instanceId = instanceIdDb->next(eid);
+    auto instanceIdResult = instanceIdDb->next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     uint8_t eventMessageGlobalEnable =
         PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_ASYNC_KEEP_ALIVE;
     uint8_t transportProtocolType = PLDM_TRANSPORT_PROTOCOL_TYPE_MCTP;
diff --git a/oem/ibm/host-bmc/host_lamp_test.cpp b/oem/ibm/host-bmc/host_lamp_test.cpp
index e7485d8..e99e423 100644
--- a/oem/ibm/host-bmc/host_lamp_test.cpp
+++ b/oem/ibm/host-bmc/host_lamp_test.cpp
@@ -109,7 +109,16 @@ uint16_t HostLampTest::getEffecterID()
 uint8_t HostLampTest::setHostStateEffecter(uint16_t effecterID)
 {
     constexpr uint8_t effecterCount = 1;
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult = instanceIdDb.next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctp_eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return instanceIdResult.error().rc();
+    }
+    auto instanceId = instanceIdResult.value();
 
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + sizeof(effecterID) + sizeof(effecterCount) +
diff --git a/oem/ibm/libpldmresponder/oem_ibm_handler.cpp b/oem/ibm/libpldmresponder/oem_ibm_handler.cpp
index 9721bc1..4e59914 100644
--- a/oem/ibm/libpldmresponder/oem_ibm_handler.cpp
+++ b/oem/ibm/libpldmresponder/oem_ibm_handler.cpp
@@ -524,7 +524,16 @@ void pldm::responder::oem_ibm_platform::Handler::sendStateSensorEvent(
     eventClass->sensor_offset = sensorOffset;
     eventClass->event_state = eventState;
     eventClass->previous_event_state = prevEventState;
-    auto instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult = instanceIdDb.next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctp_eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_PLATFORM_EVENT_MESSAGE_MIN_REQ_BYTES +
         sensorEventDataVec.size());
diff --git a/oem/ibm/libpldmresponder/platform_oem_ibm.cpp b/oem/ibm/libpldmresponder/platform_oem_ibm.cpp
index 47c1e53..70ce0de 100644
--- a/oem/ibm/libpldmresponder/platform_oem_ibm.cpp
+++ b/oem/ibm/libpldmresponder/platform_oem_ibm.cpp
@@ -61,7 +61,16 @@ int sendBiosAttributeUpdateEvent(
             "ERROR", e);
     }
 
-    auto instanceId = instanceIdDb->next(eid);
+    auto instanceIdResult = instanceIdDb->next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return instanceIdResult.error().rc();
+    }
+    auto instanceId = instanceIdResult.value();
 
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + sizeof(pldm_bios_attribute_update_event_req) -
diff --git a/oem/ibm/requester/dbus_to_file_handler.cpp b/oem/ibm/requester/dbus_to_file_handler.cpp
index 8ed966c..8d9d294 100644
--- a/oem/ibm/requester/dbus_to_file_handler.cpp
+++ b/oem/ibm/requester/dbus_to_file_handler.cpp
@@ -40,7 +40,16 @@ void DbusToFileHandler::sendNewFileAvailableCmd(uint64_t fileSize)
             "xyz.openbmc_project.bmc.pldm.InternalFailure");
         return;
     }
-    auto instanceId = instanceIdDb->next(mctp_eid);
+    auto instanceIdResult = instanceIdDb->next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctp_eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_NEW_FILE_REQ_BYTES);
     auto request = reinterpret_cast<pldm_msg*>(requestMsg.data());
@@ -252,7 +261,16 @@ void DbusToFileHandler::newFileAvailableSendToHost(
             "xyz.openbmc_project.bmc.pldm.InternalFailure");
         return;
     }
-    auto instanceId = instanceIdDb->next(mctp_eid);
+    auto instanceIdResult = instanceIdDb->next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctp_eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + PLDM_NEW_FILE_REQ_BYTES);
     auto request = reinterpret_cast<pldm_msg*>(requestMsg.data());
diff --git a/platform-mc/dbus_to_terminus_effecters.cpp b/platform-mc/dbus_to_terminus_effecters.cpp
index 0c27f95..ff5f3cb 100644
--- a/platform-mc/dbus_to_terminus_effecters.cpp
+++ b/platform-mc/dbus_to_terminus_effecters.cpp
@@ -481,7 +481,16 @@ int HostEffecterParser::setTerminusNumericEffecter(
         }
     }
 
-    auto instanceId = instanceIdDb->next(mctpEid);
+    auto instanceIdResult = instanceIdDb->next(mctpEid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctpEid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return instanceIdResult.error().rc();
+    }
+    auto instanceId = instanceIdResult.value();
     int rc = PLDM_ERROR;
     std::vector<uint8_t> requestMsg;
 
@@ -620,7 +629,16 @@ int HostEffecterParser::setHostStateEffecter(
     }
 
     uint8_t& compEffCnt = hostEffecterInfo[effecterInfoIndex].compEffecterCnt;
-    auto instanceId = instanceIdDb->next(mctpEid);
+    auto instanceIdResult = instanceIdDb->next(mctpEid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", mctpEid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return instanceIdResult.error().rc();
+    }
+    auto instanceId = instanceIdResult.value();
 
     std::vector<uint8_t> requestMsg(
         sizeof(pldm_msg_hdr) + sizeof(effecterId) + sizeof(compEffCnt) +
diff --git a/platform-mc/terminus_manager.cpp b/platform-mc/terminus_manager.cpp
index 406c70a..5e346b9 100644
--- a/platform-mc/terminus_manager.cpp
+++ b/platform-mc/terminus_manager.cpp
@@ -442,7 +442,16 @@ exec::task<int> TerminusManager::sendRecvPldmMsgOverMctp(
 
 exec::task<int> TerminusManager::getTidOverMctp(mctp_eid_t eid, pldm_tid_t* tid)
 {
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        co_return instanceIdResult.error().rc();
+    }
+    auto instanceId = instanceIdResult.value();
     Request request(sizeof(pldm_msg_hdr));
     auto requestMsg = new (request.data()) pldm_msg;
     auto rc = encode_get_tid_req(instanceId, requestMsg);
@@ -488,7 +497,16 @@ exec::task<int> TerminusManager::getTidOverMctp(mctp_eid_t eid, pldm_tid_t* tid)
 
 exec::task<int> TerminusManager::setTidOverMctp(mctp_eid_t eid, pldm_tid_t tid)
 {
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        co_return instanceIdResult.error().rc();
+    }
+    auto instanceId = instanceIdResult.value();
     Request request(sizeof(pldm_msg_hdr) + sizeof(pldm_set_tid_req));
     auto requestMsg = new (request.data()) pldm_msg;
     auto rc = encode_set_tid_req(instanceId, tid, requestMsg);
@@ -662,7 +680,17 @@ exec::task<int> TerminusManager::sendRecvPldmMsg(
 
     auto eid = std::get<0>(mctpInfo.value());
     auto requestMsg = new (request.data()) pldm_msg;
-    requestMsg->hdr.instance_id = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for EID {EID}: rc={RC}, msg={MSG}",
+            "EID", eid, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        co_return instanceIdResult.error().rc();
+    }
+    requestMsg->hdr.instance_id = instanceIdResult.value();
+
     auto rc = co_await sendRecvPldmMsgOverMctp(eid, request, responseMsg,
                                                responseLen);
 
diff --git a/pldmtool/pldm_cmd_helper.cpp b/pldmtool/pldm_cmd_helper.cpp
index cbcf827..c71a69d 100644
--- a/pldmtool/pldm_cmd_helper.cpp
+++ b/pldmtool/pldm_cmd_helper.cpp
@@ -88,7 +88,15 @@ void fillCompletionCode(uint8_t completionCode, ordered_json& data,
 
 void CommandInterface::exec()
 {
-    instanceId = instanceIdDb.next(mctp_eid);
+    auto instanceIdResult = instanceIdDb.next(mctp_eid);
+    if (!instanceIdResult)
+    {
+        std::cerr << "Failed to allocate instance id for EID " << mctp_eid
+                  << ": rc = " << instanceIdResult.error().rc()
+                  << ", msg = " << instanceIdResult.error().msg() << "\n";
+        return;
+    }
+    auto instanceId = instanceIdResult.value();
     auto [rc, requestMsg] = createRequestMsg();
     if (rc != PLDM_SUCCESS)
     {
diff --git a/requester/test/handler_test.cpp b/requester/test/handler_test.cpp
index caa4663..57b15be 100644
--- a/requester/test/handler_test.cpp
+++ b/requester/test/handler_test.cpp
@@ -79,7 +79,9 @@ TEST_F(HandlerTest, singleRequestResponseScenario)
         pldmTransport, event, instanceIdDb, false, seconds(1), 2,
         milliseconds(100));
     pldm::Request request{};
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    ASSERT_TRUE(instanceIdResult) << "Failed to allocate instanceId";
+    auto instanceId = instanceIdResult.value();
     EXPECT_EQ(instanceId, 0);
     auto rc = reqHandler.registerRequest(
         eid, instanceId, 0, 0, std::move(request),
@@ -102,7 +104,9 @@ TEST_F(HandlerTest, singleRequestInstanceIdTimerExpired)
         pldmTransport, event, instanceIdDb, false, seconds(1), 2,
         milliseconds(100));
     pldm::Request request{};
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    ASSERT_TRUE(instanceIdResult) << "Failed to allocate instanceId";
+    auto instanceId = instanceIdResult.value();
     EXPECT_EQ(instanceId, 0);
     auto rc = reqHandler.registerRequest(
         eid, instanceId, 0, 0, std::move(request),
@@ -123,7 +127,9 @@ TEST_F(HandlerTest, multipleRequestResponseScenario)
         pldmTransport, event, instanceIdDb, false, seconds(2), 2,
         milliseconds(100));
     pldm::Request request{};
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    ASSERT_TRUE(instanceIdResult) << "Failed to allocate instanceId";
+    auto instanceId = instanceIdResult.value();
     EXPECT_EQ(instanceId, 0);
     auto rc = reqHandler.registerRequest(
         eid, instanceId, 0, 0, std::move(request),
@@ -133,7 +139,9 @@ TEST_F(HandlerTest, multipleRequestResponseScenario)
     EXPECT_EQ(rc, PLDM_SUCCESS);
 
     pldm::Request requestNxt{};
-    auto instanceIdNxt = instanceIdDb.next(eid);
+    auto instanceIdNxtResult = instanceIdDb.next(eid);
+    ASSERT_TRUE(instanceIdNxtResult) << "Failed to alloc instanceId";
+    auto instanceIdNxt = instanceIdNxtResult.value();
     EXPECT_EQ(instanceIdNxt, 1);
     rc = reqHandler.registerRequest(
         eid, instanceIdNxt, 0, 0, std::move(requestNxt),
@@ -168,7 +176,9 @@ TEST_F(HandlerTest, singleRequestResponseScenarioUsingCoroutine)
         pldmTransport, event, instanceIdDb, false, seconds(1), 2,
         milliseconds(100));
 
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    ASSERT_TRUE(instanceIdResult) << "Failed to allocate instanceId";
+    auto instanceId = instanceIdResult.value();
     EXPECT_EQ(instanceId, 0);
 
     scope.spawn(
@@ -214,7 +224,9 @@ TEST_F(HandlerTest, singleRequestCancellationScenarioUsingCoroutine)
     Handler<NiceMock<MockRequest>> reqHandler(
         pldmTransport, event, instanceIdDb, false, seconds(1), 2,
         milliseconds(100));
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    ASSERT_TRUE(instanceIdResult) << "Failed to allocate instanceId";
+    auto instanceId = instanceIdResult.value();
     EXPECT_EQ(instanceId, 0);
 
     bool stopped = false;
@@ -271,7 +283,9 @@ TEST_F(HandlerTest, asyncRequestResponseByCoroutine)
     exec::async_scope scope;
     Handler<MockRequest> reqHandler(pldmTransport, event, instanceIdDb, false,
                                     seconds(1), 2, milliseconds(100));
-    auto instanceId = instanceIdDb.next(eid);
+    auto instanceIdResult = instanceIdDb.next(eid);
+    ASSERT_TRUE(instanceIdResult) << "Failed to allocate instanceId";
+    auto instanceId = instanceIdResult.value();
 
     uint8_t expectedTid = 1;
 
diff --git a/softoff/softoff.cpp b/softoff/softoff.cpp
index 9721c7e..fc60aae 100644
--- a/softoff/softoff.cpp
+++ b/softoff/softoff.cpp
@@ -271,7 +271,6 @@ int SoftPowerOff::hostSoftOff(sdeventplus::Event& event)
 {
     constexpr uint8_t effecterCount = 1;
     PldmTransport pldmTransport{};
-    uint8_t instanceID;
     uint8_t mctpEID;
 
     mctpEID = pldm::utils::readHostEID();
@@ -285,7 +284,16 @@ int SoftPowerOff::hostSoftOff(sdeventplus::Event& event)
     auto request = new (requestMsg.data()) pldm_msg;
     set_effecter_state_field stateField{
         PLDM_REQUEST_SET, PLDM_SW_TERM_GRACEFUL_SHUTDOWN_REQUESTED};
-    instanceID = instanceIdDb.next(pldmTID);
+    auto instanceIdResult = instanceIdDb.next(pldmTID);
+    if (!instanceIdResult)
+    {
+        error(
+            "Failed to allocate instance id for TID {TID}: rc={RC}, msg={MSG}",
+            "TID", pldmTID, "RC", instanceIdResult.error().rc(), "MSG",
+            instanceIdResult.error().msg());
+        return instanceIdResult.error().rc();
+    }
+    auto instanceID = instanceIdResult.value();
     auto rc = encode_set_state_effecter_states_req(
         instanceID, effecterID, effecterCount, &stateField, request);
     if (rc != PLDM_SUCCESS)
-- 
2.25.1

