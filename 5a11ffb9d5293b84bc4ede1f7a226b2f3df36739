{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f20ca807_c5e31dbf",
        "filename": "requester/mctp_endpoint_discovery.cpp",
        "patchSetId": 6
      },
      "lineNbr": 172,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2024-11-27T08:33:36Z",
      "side": 1,
      "message": "Get-Property when the object is removed will cause the error log. Can we use different to check the available of object instead of read it directly?",
      "revId": "5a11ffb9d5293b84bc4ede1f7a226b2f3df36739",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "99c864d1_9345cea0",
        "filename": "requester/mctp_endpoint_discovery.cpp",
        "patchSetId": 6
      },
      "lineNbr": 172,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-11-28T15:58:07Z",
      "side": 1,
      "message": "I understand your concern.\nCould you please clarify what method you mean by \"different\"?\nIf it involves using getsubtree and comparing, I worry that it might still result in inconsistencies with the actual MCTP tree.\n\nThank you very much for your suggestion.",
      "parentUuid": "f20ca807_c5e31dbf",
      "revId": "5a11ffb9d5293b84bc4ede1f7a226b2f3df36739",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "28da6110_b0958175",
        "filename": "requester/mctp_endpoint_discovery.cpp",
        "patchSetId": 6
      },
      "lineNbr": 172,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-11-28T16:02:26Z",
      "side": 1,
      "message": "I have tried using the same method as handling the interface added signal to read the remove signal with msg.read, in order to accurately delete the PLDM device corresponding to the EID that was actually removed.\nHowever, I found that errors such as \"no such device\" or \"address\" would occur.",
      "parentUuid": "99c864d1_9345cea0",
      "revId": "5a11ffb9d5293b84bc4ede1f7a226b2f3df36739",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4ee144d2_3b0d7b96",
        "filename": "requester/mctp_endpoint_discovery.cpp",
        "patchSetId": 6
      },
      "lineNbr": 172,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2024-11-29T03:25:37Z",
      "side": 1,
      "message": "Do you mean the `GetSubTree` and `GetSubTreePaths` does not response all of EP object paths?\n\n```\nvoid MctpDiscovery::removeEndpoints(sdbusplus::message_t\u0026)\n{\n    MctpInfos mctpInfos;\n    MctpInfos removedInfos;\n    std::map\u003cMctpInfo, Availability\u003e currentMctpInfoMap;\n    getMctpInfos(currentMctpInfoMap);\n    for (const auto\u0026 mapIt : currentMctpInfoMap)\n    {\n        mctpInfos.push_back(mapIt.first);\n    }\n    removeFromExistingMctpInfos(mctpInfos, removedInfos);\n    handleRemovedMctpEndpoints(removedInfos);\n}\n```\nIn the current pldmd code, to identify the removed MCTP object paths, we check the available MCTP EP object paths by call `getSubtree` method. Then comparing the stored object paths with currently available object paths to find the removed ones.\nI wonder how the object still available in `handleRemovedMctpEndpoints` steps?\n\nIs it because `getSubtree` in `getMctpInfos` does not work correctly? Does it missed some available EP object path?",
      "parentUuid": "28da6110_b0958175",
      "revId": "5a11ffb9d5293b84bc4ede1f7a226b2f3df36739",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb861349_4d13ef41",
        "filename": "requester/mctp_endpoint_discovery.cpp",
        "patchSetId": 6
      },
      "lineNbr": 172,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-11-29T08:53:04Z",
      "side": 1,
      "message": "Yes, it seems the current `getSubtree` function is not working correctly.\n\nFrom my understanding, `pldm` uses `getSubtree` to determine the available object paths and then removes the object paths in `existingMctpInfos` that are not in `getSubtree`.\n\nHowever, it appears that the available object paths obtained from `getSubtree` may not be accurate, causing `pldm` to mistakenly remove available object paths.\n\nWith my commit applied, if the `getSubtree` results are accurate, the code should reach:\n\n```cpp\ncatch (const sdbusplus::exception::SdBusError\u0026 e)\n{\n    removedInfos.emplace_back(mctpInfo);\n}\n```\n\nbecause those object paths are actually not available. \nBut in our system, it is possible to reach:\n\n```cpp\ntry\n{\n    pldm::utils::DBusHandler().getDbusPropertyVariant(MCTPObject.c_str(), \"EID\", MCTPInterface);\n    info(\"Endpoint with EID \u0027{EID}\u0027 exists at object path \u0027{OBJECT}\u0027, not removing\",\n         \"EID\", std::get\u003c0\u003e(mctpInfo), \"OBJECT\", MCTPObject);\n}\n```\n\nwhich prints the additional debug message I added.\n\nAdditionally, in our system, when performing a 12V off on a server board, multiple MCTP EIDs are removed almost simultaneously.\nI have observed that the `getSubtree` results can be inconsistent during these instances.",
      "parentUuid": "4ee144d2_3b0d7b96",
      "revId": "5a11ffb9d5293b84bc4ede1f7a226b2f3df36739",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "988c1dd4_2cc58d4d",
        "filename": "requester/mctp_endpoint_discovery.cpp",
        "patchSetId": 6
      },
      "lineNbr": 172,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-11-29T09:01:33Z",
      "side": 1,
      "message": "The results of getSubtree are sometimes inconsistent with the actual situation. When this happens, it can lead to the erroneous removal of existing pldm devices.",
      "parentUuid": "fb861349_4d13ef41",
      "revId": "5a11ffb9d5293b84bc4ede1f7a226b2f3df36739",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}